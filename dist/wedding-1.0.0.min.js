(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"./plumbing/index.coffee":[function(require,module,exports){
var hub, page, scene;

hub = require('odo-hub');

window.hub = hub;

page = require('page');

scene = require('./scene');

require('./intent');

page();

window.__loadinghandle.fin();



},{"./intent":"/Users/tcoats/Mayhem/wedding/plumbing/intent.js","./scene":"/Users/tcoats/Mayhem/wedding/plumbing/scene.js","odo-hub":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/hub.js","page":"/Users/tcoats/Mayhem/wedding/node_modules/page/index.js"}],"/Users/tcoats/Mayhem/wedding/components/default.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var component, dom, emblem, form2js, hub, inject, ql, ref, rsvp, widget;

ref = require('odojs'), component = ref.component, dom = ref.dom, widget = ref.widget;

inject = require('injectinto');

ql = require('odoql/ql');

hub = require('odo-hub');

form2js = require('../plumbing/form2js');

emblem = require('./emblem');

rsvp = component({
  render: function(state, params) {
    var checkboxattrs, contents, fn, i, index, items, len, name, nameinput, ref1, whoattrs;
    nameinput = function(index, name, cb) {
      return dom('div', [
        dom('input', {
          onkeyup: function(e) {
            if (e.keyCode === 13) {
              return cb(e.target.value);
            }
          },
          onblur: function(e) {
            return cb(e.target.value);
          },
          attributes: {
            name: params.eventid + ".attending[" + index + "]",
            type: 'text',
            autocomplete: 'off',
            autocorrect: 'off',
            autocapitalize: 'off',
            value: name
          }
        })
      ]);
    };
    items = [];
    ref1 = state.attending;
    fn = function(index) {
      return items.push(nameinput(index, name, function(newname) {
        return hub.emit("{eventid} attendee {index} is {name}", {
          eventid: params.eventid,
          index: index,
          name: newname
        });
      }));
    };
    for (index = i = 0, len = ref1.length; i < len; index = ++i) {
      name = ref1[index];
      fn(index);
    }
    checkboxattrs = {
      name: params.eventid + ".going",
      type: 'checkbox',
      value: 'true'
    };
    if (state.going) {
      checkboxattrs.checked = 'checked';
    }
    contents = [
      dom('label', [
        dom('span', "RSVP to the " + params.eventtitle), dom('input', {
          attributes: checkboxattrs,
          onchange: function(e) {
            return hub.emit('{eventid} RSVP {attending}', {
              eventid: params.eventid,
              attending: e.target.checked
            });
          }
        }), dom('span')
      ])
    ];
    whoattrs = {};
    if (!state.going) {
      whoattrs.style = 'display: none;';
    }
    contents.push(dom('div', {
      attributes: whoattrs
    }, [dom('h4', 'Who is attending?'), dom('div', items)]));
    return dom('div', contents);
  }
});

inject.bind('page:default', component({
  query: function(params) {
    return {
      invite: ql.query('invites', 'asdf')
    };
  },
  render: function(state, params) {
    var submit, titileattr;
    submit = function(e) {
      var data;
      data = form2js(e.target, null, false);
      console.log(JSON.stringify(data, null, 2));
      return e.preventDefault();
    };
    titileattr = {
      attributes: {
        "class": 'title',
        src: '/title.png'
      }
    };
    return dom('div', {
      attributes: {
        "class": 'wrapper'
      }
    }, [
      dom('div', {
        attributes: {
          "class": 'nb nb-top'
        }
      }, [emblem()]), dom('div', {
        attributes: {
          "class": 'nb nb-section'
        }
      }, [
        dom('h1', state.invite.to), dom('form', {
          onsubmit: submit
        }, [
          rsvp(state.invite['prewedding'], {
            eventid: 'prewedding',
            eventtitle: 'Pre Wedding Celebrations'
          }), rsvp(state.invite['ceremony'], {
            eventid: 'ceremony',
            eventtitle: 'Wedding Ceremony'
          }), rsvp(state.invite['reception'], {
            eventid: 'reception',
            eventtitle: 'Wedding Reception'
          }), dom('input', {
            attributes: {
              type: 'submit',
              value: 'Go'
            }
          })
        ])
      ]), dom('div', {
        attributes: {
          "class": 'nb nb-bottom'
        }
      }, [emblem()])
    ]);
  }
}));

},{"../plumbing/form2js":"/Users/tcoats/Mayhem/wedding/plumbing/form2js.js","./emblem":"/Users/tcoats/Mayhem/wedding/components/emblem.js","injectinto":"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js","odo-hub":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/hub.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js","odoql/ql":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql.js"}],"/Users/tcoats/Mayhem/wedding/components/emblem.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var Emblem, component, inject, ref, svg;

ref = require('odojs'), svg = ref.svg, component = ref.component;

inject = require('injectinto');

require('svg4everybody');

Emblem = component({
  render: function() {
    return svg('svg', {
      attributes: {
        role: 'img',
        "class": 'emblem'
      }
    }, [
      svg('use', {
        'xlink:href': "/dist/wedding-1.0.0.min.svg#emblem"
      })
    ]);
  }
});

inject.bind('emblem', Emblem);

module.exports = Emblem;

},{"injectinto":"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js","svg4everybody":"/Users/tcoats/Mayhem/wedding/node_modules/svg4everybody/svg4everybody.js"}],"/Users/tcoats/Mayhem/wedding/components/errors.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var component, dom, inject, ref, svg;

ref = require('odojs'), component = ref.component, dom = ref.dom, svg = ref.svg;

inject = require('injectinto');

inject.bind('page:error', component({
  render: function(state, params) {
    var titileattr;
    titileattr = {
      attributes: {
        "class": 'title'
      },
      style: {
        width: '100%'
      }
    };
    return dom('div', {
      attributes: {
        "class": 'wrapper error grid grid--center'
      }
    }, [
      dom('div', [
        dom('div', {
          attributes: {
            "class": 'logo'
          }
        }, [
          svg('svg', titileattr, [
            svg('use', {
              'xlink:href': "/dist/wedding-1.0.0.min.svg#title"
            })
          ])
        ]), dom('div', [dom('h1', params.page.message), dom('p', params.page.details)])
      ])
    ]);
  }
}));

},{"injectinto":"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js"}],"/Users/tcoats/Mayhem/wedding/components/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
require('./errors');

require('./default');

},{"./default":"/Users/tcoats/Mayhem/wedding/components/default.js","./errors":"/Users/tcoats/Mayhem/wedding/components/errors.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/browserify/node_modules/browser-resolve/empty.js":[function(require,module,exports){

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/browserify/node_modules/process/browser.js":[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;

function drainQueue() {
    if (draining) {
        return;
    }
    draining = true;
    var currentQueue;
    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        var i = -1;
        while (++i < len) {
            currentQueue[i]();
        }
        len = queue.length;
    }
    draining = false;
}
process.nextTick = function (fun) {
    queue.push(fun);
    if (!draining) {
        setTimeout(drainQueue, 0);
    }
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

// TODO(shtylman)
process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js":[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toString = Object.prototype.toString;
var undefined;

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toString.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = Array.isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && Array.isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var bind,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

bind = function() {
  var Inject;
  Inject = (function() {
    function Inject() {
      this.clear = __bind(this.clear, this);
      this.many = __bind(this.many, this);
      this.firstornone = __bind(this.firstornone, this);
      this.first = __bind(this.first, this);
      this.oneornone = __bind(this.oneornone, this);
      this.one = __bind(this.one, this);
      this.bind = __bind(this.bind, this);
      this.bindings = {};
    }

    Inject.prototype.bind = function(key, item) {
      var i, k;
      if (typeof key === 'object') {
        for (k in key) {
          i = key[k];
          this.bind(k, i);
        }
        return;
      }
      if (this.bindings[key] == null) {
        this.bindings[key] = [];
      }
      if (Array.isArray(item)) {
        return this.bindings[key] = this.bindings[key].concat(item);
      } else {
        return this.bindings[key].push(item);
      }
    };

    Inject.prototype.one = function(key) {
      var items;
      if (this.bindings[key] == null) {
        throw "" + key + " not found";
      }
      items = this.bindings[key];
      if (items.length > 1) {
        throw "" + key + " too many bound";
      }
      return items[0];
    };

    Inject.prototype.oneornone = function(key) {
      var items;
      if (this.bindings[key] == null) {
        return null;
      }
      items = this.bindings[key];
      if (items.length > 1) {
        throw "" + key + " too many bound";
      }
      return items[0];
    };

    Inject.prototype.first = function(key) {
      if (this.bindings[key] == null) {
        throw "" + key + " not found";
      }
      return this.bindings[key][0];
    };

    Inject.prototype.firstornone = function(key) {
      if (this.bindings[key] == null) {
        return null;
      }
      return this.bindings[key][0];
    };

    Inject.prototype.many = function(key) {
      if (this.bindings[key] == null) {
        return [];
      }
      return this.bindings[key];
    };

    Inject.prototype.clear = function(key) {
      return delete this.bindings[key];
    };

    return Inject;

  })();
  return new Inject;
};

if (typeof define !== "undefined" && define !== null) {
  define([], bind);
} else if (typeof module !== "undefined" && module !== null) {
  module.exports = bind();
} else {
  window.inject = bind();
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var bind;

bind = function() {
  return {
    series: function(tasks, callback) {
      var next, result;
      tasks = tasks.slice(0);
      next = function(cb) {
        var task;
        if (tasks.length === 0) {
          return cb();
        }
        task = tasks.shift();
        return task(function() {
          return next(cb);
        });
      };
      result = function(cb) {
        return next(cb);
      };
      if (callback != null) {
        result(callback);
      }
      return result;
    },
    parallel: function(tasks, callback) {
      var count, result;
      count = tasks.length;
      result = function(cb) {
        var task, _i, _len, _results;
        if (count === 0) {
          return cb();
        }
        _results = [];
        for (_i = 0, _len = tasks.length; _i < _len; _i++) {
          task = tasks[_i];
          _results.push(task(function() {
            count--;
            if (count === 0) {
              return cb();
            }
          }));
        }
        return _results;
      };
      if (callback != null) {
        result(callback);
      }
      return result;
    },
    delay: function(callback) {
      return setTimeout(callback, 1);
    }
  };
};

module.exports = bind();

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/hub.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var Sequencer, async, bind, template,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

Sequencer = require('odo-sequencer');

async = require('odo-async');

template = require('odo-template');

bind = function() {
  var Hub;
  Hub = (function() {
    function Hub() {
      this.ready = __bind(this.ready, this);
      this.emit = __bind(this.emit, this);
      this.all = __bind(this.all, this);
      this.any = __bind(this.any, this);
      this.once = __bind(this.once, this);
      this._once = __bind(this._once, this);
      this.every = __bind(this.every, this);
      this._every = __bind(this._every, this);
      this._listeners = {};
      this._all = [];
      this._seq = new Sequencer();
    }

    Hub.prototype._every = function(e, cb) {
      if (this._listeners[e] == null) {
        this._listeners[e] = [];
      }
      this._listeners[e].push(cb);
      return {
        off: (function(_this) {
          return function() {
            var index;
            index = _this._listeners[e].indexOf(cb);
            if (index !== -1) {
              return _this._listeners[e].splice(index, 1);
            }
          };
        })(this)
      };
    };

    Hub.prototype.every = function(events, cb) {
      var bindings, e, _i, _len;
      if (!(events instanceof Array)) {
        events = [events];
      }
      bindings = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          e = events[_i];
          _results.push({
            event: e
          });
        }
        return _results;
      })();
      for (_i = 0, _len = bindings.length; _i < _len; _i++) {
        e = bindings[_i];
        e.binding = this._every(e.event, cb);
      }
      return {
        off: (function(_this) {
          return function() {
            var _j, _len1, _results;
            _results = [];
            for (_j = 0, _len1 = bindings.length; _j < _len1; _j++) {
              e = bindings[_j];
              _results.push(e.binding.off());
            }
            return _results;
          };
        })(this)
      };
    };

    Hub.prototype._once = function(e, cb) {
      var binding;
      binding = this.every(e, (function(_this) {
        return function(payload, callback) {
          binding.off();
          return cb(payload, callback);
        };
      })(this));
      return {
        off: function() {
          return binding.off();
        }
      };
    };

    Hub.prototype.once = function(events, cb) {
      var bindings, count, e, _i, _len;
      if (!(events instanceof Array)) {
        events = [events];
      }
      count = 0;
      bindings = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          e = events[_i];
          count++;
          _results.push({
            event: e,
            complete: false
          });
        }
        return _results;
      })();
      for (_i = 0, _len = bindings.length; _i < _len; _i++) {
        e = bindings[_i];
        e.binding = this._once(e.event, function(m, callback) {
          count--;
          e.complete = true;
          if (count === 0) {
            return cb(m, callback);
          } else {
            return callback();
          }
        });
      }
      return {
        off: function() {
          var _j, _len1, _results;
          _results = [];
          for (_j = 0, _len1 = bindings.length; _j < _len1; _j++) {
            e = bindings[_j];
            _results.push(e.binding.off());
          }
          return _results;
        }
      };
    };

    Hub.prototype.any = function(events, cb) {
      var bindings, e, unbind, _i, _len;
      bindings = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = events.length; _i < _len; _i++) {
          e = events[_i];
          _results.push({
            event: e
          });
        }
        return _results;
      })();
      unbind = function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = bindings.length; _i < _len; _i++) {
          e = bindings[_i];
          _results.push(e.binding.off());
        }
        return _results;
      };
      for (_i = 0, _len = bindings.length; _i < _len; _i++) {
        e = bindings[_i];
        e.binding = this._once(e.event, function() {
          unbind();
          return cb();
        });
      }
      return {
        off: unbind
      };
    };

    Hub.prototype.all = function(cb) {
      this._all.push(cb);
      return {
        off: function() {
          var index;
          index = this._all.indexOf(cb);
          if (index !== -1) {
            return this._all.splice(index, 1);
          }
        }
      };
    };

    Hub.prototype.emit = function(e, m, ecb) {
      var description, listener, tasks, _fn, _fn1, _i, _j, _len, _len1, _ref, _ref1;
      description = "" + (template(e, m));
      tasks = [];
      _ref = this._all;
      _fn = (function(_this) {
        return function(listener) {
          return tasks.push(function(pcb) {
            return _this._seq.exec(description, function(scb) {
              return listener(e, description, m, function() {
                pcb();
                return scb();
              });
            });
          });
        };
      })(this);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        listener = _ref[_i];
        _fn(listener);
      }
      if (this._listeners[e] != null) {
        _ref1 = this._listeners[e].slice();
        _fn1 = (function(_this) {
          return function(listener) {
            return tasks.push(function(pcb) {
              return _this._seq.exec(description, function(scb) {
                return listener(m, function() {
                  pcb();
                  return scb();
                });
              });
            });
          };
        })(this);
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          listener = _ref1[_j];
          _fn1(listener);
        }
      }
      return async.parallel(tasks, function() {
        if (ecb != null) {
          return ecb();
        }
      });
    };

    Hub.prototype.ready = function(cb) {
      return this._seq.ready(cb);
    };

    return Hub;

  })();
  return new Hub();
};

module.exports = bind();

},{"odo-async":"/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js","odo-sequencer":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/node_modules/odo-sequencer/sequencer.js","odo-template":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/node_modules/odo-template/template.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/node_modules/odo-sequencer/sequencer.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var async, bind,
  __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

async = require('odo-async');

bind = function() {
  var Sequencer;
  return Sequencer = (function() {
    function Sequencer() {
      this.ready = __bind(this.ready, this);
      this.exec = __bind(this.exec, this);
      this._next = __bind(this._next, this);
      this._queue = [];
      this._inprogress = false;
      this._timeout = 1000;
      this._ready = [];
    }

    Sequencer.prototype._next = function() {
      var duration, item;
      this._inprogress = true;
      if (this._interval != null) {
        clearInterval(this._interval);
      }
      if (this._queue.length === 0) {
        if (this._ready.length === 0) {
          return this._inprogress = false;
        }
        this._queue.push({
          description: 'ready',
          action: this._ready.shift()
        });
      }
      item = this._queue.shift();
      duration = 0;
      this._interval = setInterval((function(_this) {
        return function() {
          duration += _this._timeout;
          return console.log("? " + item.description + " has been running for " + (duration / 1000) + " seconds");
        };
      })(this), this._timeout);
      return item.action((function(_this) {
        return function() {
          if (item.callback != null) {
            item.callback();
          }
          return _this._next();
        };
      })(this));
    };

    Sequencer.prototype.exec = function(description, action, cb) {
      this._queue.push({
        description: description,
        action: action,
        callback: cb
      });
      if (!this._inprogress) {
        return async.delay(this._next);
      }
    };

    Sequencer.prototype.ready = function(callback) {
      if (!this._inprogress) {
        return callback(function() {});
      }
      return this._ready.push(callback);
    };

    return Sequencer;

  })();
};

module.exports = bind();

},{"odo-async":"/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/node_modules/odo-template/template.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var bind;

bind = function() {
  return function(string, payload) {
    if (payload == null) {
      return string;
    }
    return string.replace(/{([^{}]+)}/g, function(original, key) {
      if (payload[key] == null) {
        return original;
      }
      return payload[key];
    });
  };
};

module.exports = bind();

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/layers.coffee":[function(require,module,exports){
var extend;

extend = require('extend');

module.exports = function(initialState) {
  var _layers, _state;
  _state = {};
  _layers = [];
  if (initialState != null) {
    extend(true, _state, initialState);
  }
  return {
    apply: function(diff) {
      return extend(true, _state, diff);
    },
    clear: function() {
      return _state = {};
    },
    get: function() {
      var i, layer, len, result;
      result = {};
      extend(result, _state);
      for (i = 0, len = _layers.length; i < len; i++) {
        layer = _layers[i];
        extend(true, result, layer);
      }
      return result;
    },
    layer: function(layer) {
      _layers.push(layer);
      return {
        rollback: function() {
          index(_layers.indexOf(layer));
          return _layers.splice(index, 1);
        },
        commit: function() {
          index(_layers.indexOf(layer));
          _layers.splice(index, 1);
          return extend(_state, layer);
        }
      };
    }
  };
};



},{"extend":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/extend/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/extend/index.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odo-async/async.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/extend/index.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js":[function(require,module,exports){

var Pipe = require('../pipe').Pipe;

var Context = function Context(){
};

Context.prototype.setResult = function(result) {
	this.result = result;
	this.hasResult = true;
	return this;
};

Context.prototype.exit = function() {
	this.exiting = true;
	return this;
};

Context.prototype.switchTo = function(next, pipe) {
	if (typeof next === 'string' || next instanceof Pipe) {
		this.nextPipe = next;
	} else {
		this.next = next;
		if (pipe) {
			this.nextPipe = pipe;
		}
	}
	return this;
};

Context.prototype.push = function(child, name) {
	child.parent = this;
	if (typeof name !== 'undefined') {
		child.childName = name;
	}
	child.root = this.root || this;
	child.options = child.options || this.options;
	if (!this.children) {
		this.children = [child];
		this.nextAfterChildren = this.next || null;
		this.next = child;
	} else {
		this.children[this.children.length - 1].next = child;
		this.children.push(child);
	}
	child.next = this;
	return this;
};

exports.Context = Context;

},{"../pipe":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js":[function(require,module,exports){
var Context = require('./context').Context;

var DiffContext = function DiffContext(left, right) {
  this.left = left;
  this.right = right;
  this.pipe = 'diff';
};

DiffContext.prototype = new Context();

exports.DiffContext = DiffContext;

},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js":[function(require,module,exports){
var Context = require('./context').Context;

var PatchContext = function PatchContext(left, delta) {
  this.left = left;
  this.delta = delta;
  this.pipe = 'patch';
};

PatchContext.prototype = new Context();

exports.PatchContext = PatchContext;

},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js":[function(require,module,exports){
var Context = require('./context').Context;

var ReverseContext = function ReverseContext(delta) {
  this.delta = delta;
  this.pipe = 'reverse';
};

ReverseContext.prototype = new Context();

exports.ReverseContext = ReverseContext;

},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/date-reviver.js":[function(require,module,exports){
// use as 2nd parameter for JSON.parse to revive Date instances
module.exports = function dateReviver(key, value) {
  var parts;
  if (typeof value === 'string') {
    parts = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d*))?(Z|([+\-])(\d{2}):(\d{2}))$/.exec(value);
    if (parts) {
      return new Date(Date.UTC(+parts[1], +parts[2] - 1, +parts[3], +parts[4], +parts[5], +parts[6], +(parts[7] || 0)));
    }
  }
  return value;
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/diffpatcher.js":[function(require,module,exports){
var Processor = require('./processor').Processor;
var Pipe = require('./pipe').Pipe;
var DiffContext = require('./contexts/diff').DiffContext;
var PatchContext = require('./contexts/patch').PatchContext;
var ReverseContext = require('./contexts/reverse').ReverseContext;

var trivial = require('./filters/trivial');
var nested = require('./filters/nested');
var arrays = require('./filters/arrays');
var dates = require('./filters/dates');
var texts = require('./filters/texts');

var DiffPatcher = function DiffPatcher(options) {
  this.processor = new Processor(options);
  this.processor.pipe(new Pipe('diff').append(
    nested.collectChildrenDiffFilter,
    trivial.diffFilter,
    dates.diffFilter,
    texts.diffFilter,
    nested.objectsDiffFilter,
    arrays.diffFilter
  ).shouldHaveResult());
  this.processor.pipe(new Pipe('patch').append(
    nested.collectChildrenPatchFilter,
    arrays.collectChildrenPatchFilter,
    trivial.patchFilter,
    texts.patchFilter,
    nested.patchFilter,
    arrays.patchFilter
  ).shouldHaveResult());
  this.processor.pipe(new Pipe('reverse').append(
    nested.collectChildrenReverseFilter,
    arrays.collectChildrenReverseFilter,
    trivial.reverseFilter,
    texts.reverseFilter,
    nested.reverseFilter,
    arrays.reverseFilter
  ).shouldHaveResult());
};

DiffPatcher.prototype.options = function() {
  return this.processor.options.apply(this.processor, arguments);
};

DiffPatcher.prototype.diff = function(left, right) {
  return this.processor.process(new DiffContext(left, right));
};

DiffPatcher.prototype.patch = function(left, delta) {
  return this.processor.process(new PatchContext(left, delta));
};

DiffPatcher.prototype.reverse = function(delta) {
  return this.processor.process(new ReverseContext(delta));
};

DiffPatcher.prototype.unpatch = function(right, delta) {
  return this.patch(right, this.reverse(delta));
};

exports.DiffPatcher = DiffPatcher;

},{"./contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","./contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","./contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js","./filters/arrays":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/arrays.js","./filters/dates":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/dates.js","./filters/nested":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/nested.js","./filters/texts":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/texts.js","./filters/trivial":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/trivial.js","./pipe":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js","./processor":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/processor.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/environment.js":[function(require,module,exports){

exports.isBrowser = typeof window !== 'undefined';

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/arrays.js":[function(require,module,exports){
var DiffContext = require('../contexts/diff').DiffContext;
var PatchContext = require('../contexts/patch').PatchContext;
var ReverseContext = require('../contexts/reverse').ReverseContext;

var lcs = require('./lcs');

var ARRAY_MOVE = 3;

var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

var arrayIndexOf = typeof Array.prototype.indexOf === 'function' ?
  function(array, item) {
    return array.indexOf(item);
  } : function(array, item) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  };

function arraysHaveMatchByRef(array1, array2, len1, len2) {
  for (var index1 = 0; index1 < len1; index1++) {
    var val1 = array1[index1];
    for (var index2 = 0; index2 < len2; index2++) {
      var val2 = array2[index2];
      if (val1 === val2) {
        return true;
      }
    }
  }
}

function matchItems(array1, array2, index1, index2, context) {
  var value1 = array1[index1];
  var value2 = array2[index2];
  if (value1 === value2) {
    return true;
  }
  if (typeof value1 !== 'object' || typeof value2 !== 'object') {
    return false;
  }
  var objectHash = context.objectHash;
  if (!objectHash) {
    // no way to match objects was provided, try match by position
    return context.matchByPosition && index1 === index2;
  }
  var hash1;
  var hash2;
  if (typeof index1 === 'number') {
    context.hashCache1 = context.hashCache1 || [];
    hash1 = context.hashCache1[index1];
    if (typeof hash1 === 'undefined') {
      context.hashCache1[index1] = hash1 = objectHash(value1, index1);
    }
  } else {
    hash1 = objectHash(value1);
  }
  if (typeof hash1 === 'undefined') {
    return false;
  }
  if (typeof index2 === 'number') {
    context.hashCache2 = context.hashCache2 || [];
    hash2 = context.hashCache2[index2];
    if (typeof hash2 === 'undefined') {
      context.hashCache2[index2] = hash2 = objectHash(value2, index2);
    }
  } else {
    hash2 = objectHash(value2);
  }
  if (typeof hash2 === 'undefined') {
    return false;
  }
  return hash1 === hash2;
}

var diffFilter = function arraysDiffFilter(context) {
  if (!context.leftIsArray) {
    return;
  }

  var matchContext = {
    objectHash: context.options && context.options.objectHash,
    matchByPosition: context.options && context.options.matchByPosition
  };
  var commonHead = 0;
  var commonTail = 0;
  var index;
  var index1;
  var index2;
  var array1 = context.left;
  var array2 = context.right;
  var len1 = array1.length;
  var len2 = array2.length;

  var child;

  if (len1 > 0 && len2 > 0 && !matchContext.objectHash &&
    typeof matchContext.matchByPosition !== 'boolean') {
    matchContext.matchByPosition = !arraysHaveMatchByRef(array1, array2, len1, len2);
  }

  // separate common head
  while (commonHead < len1 && commonHead < len2 &&
    matchItems(array1, array2, commonHead, commonHead, matchContext)) {
    index = commonHead;
    child = new DiffContext(context.left[index], context.right[index]);
    context.push(child, index);
    commonHead++;
  }
  // separate common tail
  while (commonTail + commonHead < len1 && commonTail + commonHead < len2 &&
    matchItems(array1, array2, len1 - 1 - commonTail, len2 - 1 - commonTail, matchContext)) {
    index1 = len1 - 1 - commonTail;
    index2 = len2 - 1 - commonTail;
    child = new DiffContext(context.left[index1], context.right[index2]);
    context.push(child, index2);
    commonTail++;
  }
  var result;
  if (commonHead + commonTail === len1) {
    if (len1 === len2) {
      // arrays are identical
      context.setResult(undefined).exit();
      return;
    }
    // trivial case, a block (1 or more consecutive items) was added
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len2 - commonTail; index++) {
      result[index] = [array2[index]];
    }
    context.setResult(result).exit();
    return;
  }
  if (commonHead + commonTail === len2) {
    // trivial case, a block (1 or more consecutive items) was removed
    result = result || {
      _t: 'a'
    };
    for (index = commonHead; index < len1 - commonTail; index++) {
      result['_' + index] = [array1[index], 0, 0];
    }
    context.setResult(result).exit();
    return;
  }
  // reset hash cache
  delete matchContext.hashCache1;
  delete matchContext.hashCache2;

  // diff is not trivial, find the LCS (Longest Common Subsequence)
  var trimmed1 = array1.slice(commonHead, len1 - commonTail);
  var trimmed2 = array2.slice(commonHead, len2 - commonTail);
  var seq = lcs.get(
    trimmed1, trimmed2,
    matchItems,
    matchContext
  );
  var removedItems = [];
  result = result || {
    _t: 'a'
  };
  for (index = commonHead; index < len1 - commonTail; index++) {
    if (arrayIndexOf(seq.indices1, index - commonHead) < 0) {
      // removed
      result['_' + index] = [array1[index], 0, 0];
      removedItems.push(index);
    }
  }

  var detectMove = true;
  if (context.options && context.options.arrays && context.options.arrays.detectMove === false) {
    detectMove = false;
  }
  var includeValueOnMove = false;
  if (context.options && context.options.arrays && context.options.arrays.includeValueOnMove) {
    includeValueOnMove = true;
  }

  var removedItemsLength = removedItems.length;
  for (index = commonHead; index < len2 - commonTail; index++) {
    var indexOnArray2 = arrayIndexOf(seq.indices2, index - commonHead);
    if (indexOnArray2 < 0) {
      // added, try to match with a removed item and register as position move
      var isMove = false;
      if (detectMove && removedItemsLength > 0) {
        for (var removeItemIndex1 = 0; removeItemIndex1 < removedItemsLength; removeItemIndex1++) {
          index1 = removedItems[removeItemIndex1];
          if (matchItems(trimmed1, trimmed2, index1 - commonHead,
            index - commonHead, matchContext)) {
            // store position move as: [originalValue, newPosition, ARRAY_MOVE]
            result['_' + index1].splice(1, 2, index, ARRAY_MOVE);
            if (!includeValueOnMove) {
              // don't include moved value on diff, to save bytes
              result['_' + index1][0] = '';
            }

            index2 = index;
            child = new DiffContext(context.left[index1], context.right[index2]);
            context.push(child, index2);
            removedItems.splice(removeItemIndex1, 1);
            isMove = true;
            break;
          }
        }
      }
      if (!isMove) {
        // added
        result[index] = [array2[index]];
      }
    } else {
      // match, do inner diff
      index1 = seq.indices1[indexOnArray2] + commonHead;
      index2 = seq.indices2[indexOnArray2] + commonHead;
      child = new DiffContext(context.left[index1], context.right[index2]);
      context.push(child, index2);
    }
  }

  context.setResult(result).exit();

};
diffFilter.filterName = 'arrays';

var compare = {
  numerically: function(a, b) {
    return a - b;
  },
  numericallyBy: function(name) {
    return function(a, b) {
      return a[name] - b[name];
    };
  }
};

var patchFilter = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var index, index1;

  var delta = context.delta;
  var array = context.left;

  // first, separate removals, insertions and modifications
  var toRemove = [];
  var toInsert = [];
  var toModify = [];
  for (index in delta) {
    if (index !== '_t') {
      if (index[0] === '_') {
        // removed item from original array
        if (delta[index][2] === 0 || delta[index][2] === ARRAY_MOVE) {
          toRemove.push(parseInt(index.slice(1), 10));
        } else {
          throw new Error('only removal or move can be applied at original array indices' +
            ', invalid diff type: ' + delta[index][2]);
        }
      } else {
        if (delta[index].length === 1) {
          // added item at new array
          toInsert.push({
            index: parseInt(index, 10),
            value: delta[index][0]
          });
        } else {
          // modified item at new array
          toModify.push({
            index: parseInt(index, 10),
            delta: delta[index]
          });
        }
      }
    }
  }

  // remove items, in reverse order to avoid sawing our own floor
  toRemove = toRemove.sort(compare.numerically);
  for (index = toRemove.length - 1; index >= 0; index--) {
    index1 = toRemove[index];
    var indexDiff = delta['_' + index1];
    var removedValue = array.splice(index1, 1)[0];
    if (indexDiff[2] === ARRAY_MOVE) {
      // reinsert later
      toInsert.push({
        index: indexDiff[1],
        value: removedValue
      });
    }
  }

  // insert items, in reverse order to avoid moving our own floor
  toInsert = toInsert.sort(compare.numericallyBy('index'));
  var toInsertLength = toInsert.length;
  for (index = 0; index < toInsertLength; index++) {
    var insertion = toInsert[index];
    array.splice(insertion.index, 0, insertion.value);
  }

  // apply modifications
  var toModifyLength = toModify.length;
  var child;
  if (toModifyLength > 0) {
    for (index = 0; index < toModifyLength; index++) {
      var modification = toModify[index];
      child = new PatchContext(context.left[modification.index], modification.delta);
      context.push(child, modification.index);
    }
  }

  if (!context.children) {
    context.setResult(context.left).exit();
    return;
  }
  context.exit();
};
patchFilter.filterName = 'arrays';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    context.left[child.childName] = child.result;
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'arraysCollectChildren';

var reverseFilter = function arraysReverseFilter(context) {
  if (!context.nested) {
    if (context.delta[2] === ARRAY_MOVE) {
      context.newName = '_' + context.delta[1];
      context.setResult([context.delta[0], parseInt(context.childName.substr(1), 10), ARRAY_MOVE]).exit();
    }
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var name, child;
  for (name in context.delta) {
    if (name === '_t') {
      continue;
    }
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter.filterName = 'arrays';

var reverseArrayDeltaIndex = function(delta, index, itemDelta) {
  if (typeof index === 'string' && index[0] === '_') {
    return parseInt(index.substr(1), 10);
  } else if (isArray(itemDelta) && itemDelta[2] === 0) {
    return '_' + index;
  }

  var reverseIndex = +index;
  for (var deltaIndex in delta) {
    var deltaItem = delta[deltaIndex];
    if (isArray(deltaItem)) {
      if (deltaItem[2] === ARRAY_MOVE) {
        var moveFromIndex = parseInt(deltaIndex.substr(1), 10);
        var moveToIndex = deltaItem[1];
        if (moveToIndex === +index) {
          return moveFromIndex;
        }
        if (moveFromIndex <= reverseIndex && moveToIndex > reverseIndex) {
          reverseIndex++;
        } else if (moveFromIndex >= reverseIndex && moveToIndex < reverseIndex) {
          reverseIndex--;
        }
      } else if (deltaItem[2] === 0) {
        var deleteIndex = parseInt(deltaIndex.substr(1), 10);
        if (deleteIndex <= reverseIndex) {
          reverseIndex++;
        }
      } else if (deltaItem.length === 1 && deltaIndex <= reverseIndex) {
        reverseIndex--;
      }
    }
  }

  return reverseIndex;
};

var collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t !== 'a') {
    return;
  }
  var length = context.children.length;
  var child;
  var delta = {
    _t: 'a'
  };

  for (var index = 0; index < length; index++) {
    child = context.children[index];
    var name = child.newName;
    if (typeof name === 'undefined') {
      name = reverseArrayDeltaIndex(context.delta, child.childName, child.result);
    }
    if (delta[name] !== child.result) {
      delta[name] = child.result;
    }
  }
  context.setResult(delta).exit();
};
collectChildrenReverseFilter.filterName = 'arraysCollectChildren';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.collectChildrenPatchFilter = collectChildrenPatchFilter;
exports.reverseFilter = reverseFilter;
exports.collectChildrenReverseFilter = collectChildrenReverseFilter;

},{"../contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","../contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","../contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js","./lcs":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/lcs.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/dates.js":[function(require,module,exports){
var diffFilter = function datesDiffFilter(context) {
  if (context.left instanceof Date) {
    if (context.right instanceof Date) {
      if (context.left.getTime() !== context.right.getTime()) {
        context.setResult([context.left, context.right]);
      } else {
        context.setResult(undefined);
      }
    } else {
      context.setResult([context.left, context.right]);
    }
    context.exit();
  } else if (context.right instanceof Date) {
    context.setResult([context.left, context.right]).exit();
  }
};
diffFilter.filterName = 'dates';

exports.diffFilter = diffFilter;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/lcs.js":[function(require,module,exports){
/*

LCS implementation that supports arrays or strings

reference: http://en.wikipedia.org/wiki/Longest_common_subsequence_problem

*/

var defaultMatch = function(array1, array2, index1, index2) {
  return array1[index1] === array2[index2];
};

var lengthMatrix = function(array1, array2, match, context) {
  var len1 = array1.length;
  var len2 = array2.length;
  var x, y;

  // initialize empty matrix of len1+1 x len2+1
  var matrix = [len1 + 1];
  for (x = 0; x < len1 + 1; x++) {
    matrix[x] = [len2 + 1];
    for (y = 0; y < len2 + 1; y++) {
      matrix[x][y] = 0;
    }
  }
  matrix.match = match;
  // save sequence lengths for each coordinate
  for (x = 1; x < len1 + 1; x++) {
    for (y = 1; y < len2 + 1; y++) {
      if (match(array1, array2, x - 1, y - 1, context)) {
        matrix[x][y] = matrix[x - 1][y - 1] + 1;
      } else {
        matrix[x][y] = Math.max(matrix[x - 1][y], matrix[x][y - 1]);
      }
    }
  }
  return matrix;
};

var backtrack = function(matrix, array1, array2, index1, index2, context) {
  if (index1 === 0 || index2 === 0) {
    return {
      sequence: [],
      indices1: [],
      indices2: []
    };
  }

  if (matrix.match(array1, array2, index1 - 1, index2 - 1, context)) {
    var subsequence = backtrack(matrix, array1, array2, index1 - 1, index2 - 1, context);
    subsequence.sequence.push(array1[index1 - 1]);
    subsequence.indices1.push(index1 - 1);
    subsequence.indices2.push(index2 - 1);
    return subsequence;
  }

  if (matrix[index1][index2 - 1] > matrix[index1 - 1][index2]) {
    return backtrack(matrix, array1, array2, index1, index2 - 1, context);
  } else {
    return backtrack(matrix, array1, array2, index1 - 1, index2, context);
  }
};

var get = function(array1, array2, match, context) {
  context = context || {};
  var matrix = lengthMatrix(array1, array2, match || defaultMatch, context);
  var result = backtrack(matrix, array1, array2, array1.length, array2.length, context);
  if (typeof array1 === 'string' && typeof array2 === 'string') {
    result.sequence = result.sequence.join('');
  }
  return result;
};

exports.get = get;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/nested.js":[function(require,module,exports){
var DiffContext = require('../contexts/diff').DiffContext;
var PatchContext = require('../contexts/patch').PatchContext;
var ReverseContext = require('../contexts/reverse').ReverseContext;

var collectChildrenDiffFilter = function collectChildrenDiffFilter(context) {
  if (!context || !context.children) {
    return;
  }
  var length = context.children.length;
  var child;
  var result = context.result;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (typeof child.result === 'undefined') {
      continue;
    }
    result = result || {};
    result[child.childName] = child.result;
  }
  if (result && context.leftIsArray) {
    result._t = 'a';
  }
  context.setResult(result).exit();
};
collectChildrenDiffFilter.filterName = 'collectChildren';

var objectsDiffFilter = function objectsDiffFilter(context) {
  if (context.leftIsArray || context.leftType !== 'object') {
    return;
  }

  var name, child;
  for (name in context.left) {
    child = new DiffContext(context.left[name], context.right[name]);
    context.push(child, name);
  }
  for (name in context.right) {
    if (typeof context.left[name] === 'undefined') {
      child = new DiffContext(undefined, context.right[name]);
      context.push(child, name);
    }
  }

  if (!context.children || context.children.length === 0) {
    context.setResult(undefined).exit();
    return;
  }
  context.exit();
};
objectsDiffFilter.filterName = 'objects';

var patchFilter = function nestedPatchFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name, child;
  for (name in context.delta) {
    child = new PatchContext(context.left[name], context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
patchFilter.filterName = 'objects';

var collectChildrenPatchFilter = function collectChildrenPatchFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child;
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (context.left.hasOwnProperty(child.childName) && child.result === undefined) {
      delete context.left[child.childName];
    } else if (context.left[child.childName] !== child.result) {
      context.left[child.childName] = child.result;
    }
  }
  context.setResult(context.left).exit();
};
collectChildrenPatchFilter.filterName = 'collectChildren';

var reverseFilter = function nestedReverseFilter(context) {
  if (!context.nested) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var name, child;
  for (name in context.delta) {
    child = new ReverseContext(context.delta[name]);
    context.push(child, name);
  }
  context.exit();
};
reverseFilter.filterName = 'objects';

var collectChildrenReverseFilter = function collectChildrenReverseFilter(context) {
  if (!context || !context.children) {
    return;
  }
  if (context.delta._t) {
    return;
  }
  var length = context.children.length;
  var child;
  var delta = {};
  for (var index = 0; index < length; index++) {
    child = context.children[index];
    if (delta[child.childName] !== child.result) {
      delta[child.childName] = child.result;
    }
  }
  context.setResult(delta).exit();
};
collectChildrenReverseFilter.filterName = 'collectChildren';

exports.collectChildrenDiffFilter = collectChildrenDiffFilter;
exports.objectsDiffFilter = objectsDiffFilter;
exports.patchFilter = patchFilter;
exports.collectChildrenPatchFilter = collectChildrenPatchFilter;
exports.reverseFilter = reverseFilter;
exports.collectChildrenReverseFilter = collectChildrenReverseFilter;

},{"../contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","../contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","../contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/texts.js":[function(require,module,exports){
/* global diff_match_patch */
var TEXT_DIFF = 2;
var DEFAULT_MIN_LENGTH = 60;
var cachedDiffPatch = null;

var getDiffMatchPatch = function() {
  /*jshint camelcase: false */

  if (!cachedDiffPatch) {
    var instance;
    if (typeof diff_match_patch !== 'undefined') {
      // already loaded, probably a browser
      instance = typeof diff_match_patch === 'function' ?
        new diff_match_patch() : new diff_match_patch.diff_match_patch();
    } else if (typeof require === 'function') {
      try {
        var dmpModuleName = 'diff_match_patch_uncompressed';
        var dmp = require('../../public/external/' + dmpModuleName);
        instance = new dmp.diff_match_patch();
      } catch (err) {
        instance = null;
      }
    }
    if (!instance) {
      var error = new Error('text diff_match_patch library not found');
      error.diff_match_patch_not_found = true;
      throw error;
    }
    cachedDiffPatch = {
      diff: function(txt1, txt2) {
        return instance.patch_toText(instance.patch_make(txt1, txt2));
      },
      patch: function(txt1, patch) {
        var results = instance.patch_apply(instance.patch_fromText(patch), txt1);
        for (var i = 0; i < results[1].length; i++) {
          if (!results[1][i]) {
            var error = new Error('text patch failed');
            error.textPatchFailed = true;
          }
        }
        return results[0];
      }
    };
  }
  return cachedDiffPatch;
};

var diffFilter = function textsDiffFilter(context) {
  if (context.leftType !== 'string') {
    return;
  }
  var minLength = (context.options && context.options.textDiff &&
    context.options.textDiff.minLength) || DEFAULT_MIN_LENGTH;
  if (context.left.length < minLength ||
    context.right.length < minLength) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  // large text, use a text-diff algorithm
  var diff = getDiffMatchPatch().diff;
  context.setResult([diff(context.left, context.right), 0, TEXT_DIFF]).exit();
};
diffFilter.filterName = 'texts';

var patchFilter = function textsPatchFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-patch algorithm
  var patch = getDiffMatchPatch().patch;
  context.setResult(patch(context.left, context.delta[0])).exit();
};
patchFilter.filterName = 'texts';

var textDeltaReverse = function(delta) {
  var i, l, lines, line, lineTmp, header = null,
    headerRegex = /^@@ +\-(\d+),(\d+) +\+(\d+),(\d+) +@@$/,
    lineHeader, lineAdd, lineRemove;
  lines = delta.split('\n');
  for (i = 0, l = lines.length; i < l; i++) {
    line = lines[i];
    var lineStart = line.slice(0, 1);
    if (lineStart === '@') {
      header = headerRegex.exec(line);
      lineHeader = i;
      lineAdd = null;
      lineRemove = null;

      // fix header
      lines[lineHeader] = '@@ -' + header[3] + ',' + header[4] + ' +' + header[1] + ',' + header[2] + ' @@';
    } else if (lineStart === '+') {
      lineAdd = i;
      lines[i] = '-' + lines[i].slice(1);
      if (lines[i - 1].slice(0, 1) === '+') {
        // swap lines to keep default order (-+)
        lineTmp = lines[i];
        lines[i] = lines[i - 1];
        lines[i - 1] = lineTmp;
      }
    } else if (lineStart === '-') {
      lineRemove = i;
      lines[i] = '+' + lines[i].slice(1);
    }
  }
  return lines.join('\n');
};

var reverseFilter = function textsReverseFilter(context) {
  if (context.nested) {
    return;
  }
  if (context.delta[2] !== TEXT_DIFF) {
    return;
  }

  // text-diff, use a text-diff algorithm
  context.setResult([textDeltaReverse(context.delta[0]), 0, TEXT_DIFF]).exit();
};
reverseFilter.filterName = 'texts';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.reverseFilter = reverseFilter;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/trivial.js":[function(require,module,exports){
var isArray = (typeof Array.isArray === 'function') ?
  // use native function
  Array.isArray :
  // use instanceof operator
  function(a) {
    return a instanceof Array;
  };

var diffFilter = function trivialMatchesDiffFilter(context) {
  if (context.left === context.right) {
    context.setResult(undefined).exit();
    return;
  }
  if (typeof context.left === 'undefined') {
    if (typeof context.right === 'function') {
      throw new Error('functions are not supported');
    }
    context.setResult([context.right]).exit();
    return;
  }
  if (typeof context.right === 'undefined') {
    context.setResult([context.left, 0, 0]).exit();
    return;
  }
  if (typeof context.left === 'function' || typeof context.right === 'function') {
    throw new Error('functions are not supported');
  }
  context.leftType = context.left === null ? 'null' : typeof context.left;
  context.rightType = context.right === null ? 'null' : typeof context.right;
  if (context.leftType !== context.rightType) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'boolean' || context.leftType === 'number') {
    context.setResult([context.left, context.right]).exit();
    return;
  }
  if (context.leftType === 'object') {
    context.leftIsArray = isArray(context.left);
  }
  if (context.rightType === 'object') {
    context.rightIsArray = isArray(context.right);
  }
  if (context.leftIsArray !== context.rightIsArray) {
    context.setResult([context.left, context.right]).exit();
    return;
  }
};
diffFilter.filterName = 'trivial';

var patchFilter = function trivialMatchesPatchFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.left).exit();
    return;
  }
  context.nested = !isArray(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult(context.delta[0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult(context.delta[1]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult(undefined).exit();
    return;
  }
};
patchFilter.filterName = 'trivial';

var reverseFilter = function trivialReferseFilter(context) {
  if (typeof context.delta === 'undefined') {
    context.setResult(context.delta).exit();
    return;
  }
  context.nested = !isArray(context.delta);
  if (context.nested) {
    return;
  }
  if (context.delta.length === 1) {
    context.setResult([context.delta[0], 0, 0]).exit();
    return;
  }
  if (context.delta.length === 2) {
    context.setResult([context.delta[1], context.delta[0]]).exit();
    return;
  }
  if (context.delta.length === 3 && context.delta[2] === 0) {
    context.setResult([context.delta[0]]).exit();
    return;
  }
};
reverseFilter.filterName = 'trivial';

exports.diffFilter = diffFilter;
exports.patchFilter = patchFilter;
exports.reverseFilter = reverseFilter;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/main.js":[function(require,module,exports){

var environment = require('./environment');

var DiffPatcher = require('./diffpatcher').DiffPatcher;
exports.DiffPatcher = DiffPatcher;

exports.create = function(options){
	return new DiffPatcher(options);
};

exports.dateReviver = require('./date-reviver');

var defaultInstance;

exports.diff = function() {
	if (!defaultInstance) {
		defaultInstance = new DiffPatcher();
	}
	return defaultInstance.diff.apply(defaultInstance, arguments);
};

exports.patch = function() {
	if (!defaultInstance) {
		defaultInstance = new DiffPatcher();
	}
	return defaultInstance.patch.apply(defaultInstance, arguments);
};

exports.unpatch = function() {
	if (!defaultInstance) {
		defaultInstance = new DiffPatcher();
	}
	return defaultInstance.unpatch.apply(defaultInstance, arguments);
};

exports.reverse = function() {
	if (!defaultInstance) {
		defaultInstance = new DiffPatcher();
	}
	return defaultInstance.reverse.apply(defaultInstance, arguments);
};

if (environment.isBrowser) {
	exports.homepage = '{{package-homepage}}';
	exports.version = '{{package-version}}';
} else {
	var packageInfoModuleName = '../package.json';
	var packageInfo = require(packageInfoModuleName);
	exports.homepage = packageInfo.homepage;
	exports.version = packageInfo.version;

	var formatterModuleName = './formatters';
	var formatters = require(formatterModuleName);
	exports.formatters = formatters;
	// shortcut for console
	exports.console = formatters.console;
}

},{"./date-reviver":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/date-reviver.js","./diffpatcher":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/diffpatcher.js","./environment":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/environment.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js":[function(require,module,exports){
var Pipe = function Pipe(name) {
  this.name = name;
  this.filters = [];
};

Pipe.prototype.process = function(input) {
  if (!this.processor) {
    throw new Error('add this pipe to a processor before using it');
  }
  var debug = this.debug;
  var length = this.filters.length;
  var context = input;
  for (var index = 0; index < length; index++) {
    var filter = this.filters[index];
    if (debug) {
      this.log('filter: ' + filter.filterName);
    }
    filter(context);
    if (typeof context === 'object' && context.exiting) {
      context.exiting = false;
      break;
    }
  }
  if (!context.next && this.resultCheck) {
    this.resultCheck(context);
  }
};

Pipe.prototype.log = function(msg) {
  console.log('[jsondiffpatch] ' + this.name + ' pipe, ' + msg);
};

Pipe.prototype.append = function() {
  this.filters.push.apply(this.filters, arguments);
  return this;
};

Pipe.prototype.prepend = function() {
  this.filters.unshift.apply(this.filters, arguments);
  return this;
};

Pipe.prototype.indexOf = function(filterName) {
  if (!filterName) {
    throw new Error('a filter name is required');
  }
  for (var index = 0; index < this.filters.length; index++) {
    var filter = this.filters[index];
    if (filter.filterName === filterName) {
      return index;
    }
  }
  throw new Error('filter not found: ' + filterName);
};

Pipe.prototype.list = function() {
  var names = [];
  for (var index = 0; index < this.filters.length; index++) {
    var filter = this.filters[index];
    names.push(filter.filterName);
  }
  return names;
};

Pipe.prototype.after = function(filterName) {
  var index = this.indexOf(filterName);
  var params = Array.prototype.slice.call(arguments, 1);
  if (!params.length) {
    throw new Error('a filter is required');
  }
  params.unshift(index + 1, 0);
  Array.prototype.splice.apply(this.filters, params);
  return this;
};

Pipe.prototype.before = function(filterName) {
  var index = this.indexOf(filterName);
  var params = Array.prototype.slice.call(arguments, 1);
  if (!params.length) {
    throw new Error('a filter is required');
  }
  params.unshift(index, 0);
  Array.prototype.splice.apply(this.filters, params);
  return this;
};

Pipe.prototype.clear = function() {
  this.filters.length = 0;
  return this;
};

Pipe.prototype.shouldHaveResult = function(should) {
  if (should === false) {
    this.resultCheck = null;
    return;
  }
  if (this.resultCheck) {
    return;
  }
  var pipe = this;
  this.resultCheck = function(context) {
    if (!context.hasResult) {
      console.log(context);
      var error = new Error(pipe.name + ' failed');
      error.noResult = true;
      throw error;
    }
  };
  return this;
};

exports.Pipe = Pipe;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/processor.js":[function(require,module,exports){

var Processor = function Processor(options){
	this.selfOptions = options;
	this.pipes = {};
};

Processor.prototype.options = function(options) {
	if (options) {
		this.selfOptions = options;
	}
	return this.selfOptions;
};

Processor.prototype.pipe = function(name, pipe) {
	if (typeof name === 'string') {
		if (typeof pipe === 'undefined') {
			return this.pipes[name];
		} else {
			this.pipes[name] = pipe;
		}
	}
	if (name && name.name) {
		pipe = name;
		if (pipe.processor === this) { return pipe; }
		this.pipes[pipe.name] = pipe;
	}
	pipe.processor = this;
	return pipe;
};

Processor.prototype.process = function(input, pipe) {
	var context = input;
	context.options = this.options();
	var nextPipe = pipe || input.pipe || 'default';
	var lastPipe, lastContext;
	while (nextPipe) {
		if (typeof context.nextAfterChildren !== 'undefined') {
			// children processed and coming back to parent
			context.next = context.nextAfterChildren;
			context.nextAfterChildren = null;
		}

		if (typeof nextPipe === 'string') {
			nextPipe = this.pipe(nextPipe);
		}
		nextPipe.process(context);
		lastContext = context;
		lastPipe = nextPipe;
		nextPipe = null;
		if (context) {
			if (context.next) {
				context = context.next;
				nextPipe = lastContext.nextPipe || context.pipe || lastPipe;
			}
		}
	}
	return context.hasResult ? context.result : undefined;
};

exports.Processor = Processor;

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/odo-async/async.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql.coffee":[function(require,module,exports){
module.exports = {
  query: function(name, params, shape) {
    return {
      __query: name,
      __params: params,
      __shape: shape
    };
  },
  freshquery: function(name, params, shape) {
    return {
      __query: name,
      __params: params,
      __shape: shape,
      __fresh: true
    };
  },
  desc: require('./ql/desc'),
  merge: require('./ql/merge'),
  split: require('./ql/split'),
  diff: require('./ql/diff'),
  build: require('./ql/build'),
  exec: require('./ql/exec')
};



},{"./ql/build":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/build.coffee","./ql/desc":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/desc.coffee","./ql/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/diff.coffee","./ql/exec":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/exec.coffee","./ql/merge":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/merge.coffee","./ql/split":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/split.coffee"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/build.coffee":[function(require,module,exports){
var split;

split = require('./split');

module.exports = function(query, stores) {
  var _, fn, graph, item, key, queries, ref, result;
  queries = {};
  query = split(query, Object.keys(stores));
  ref = query.known;
  for (key in ref) {
    graph = ref[key];
    if (queries[graph.__query] == null) {
      queries[graph.__query] = {
        __query: graph.__query,
        keys: [],
        queries: {}
      };
    }
    queries[graph.__query].keys.push(key);
    queries[graph.__query].queries[key] = graph;
  }
  result = [];
  fn = function(item) {
    item.query = function(cb) {
      return stores[item.__query](item.queries, cb);
    };
    return result.push(item);
  };
  for (_ in queries) {
    item = queries[_];
    fn(item);
  }
  if (Object.keys(query.unknown).length === 0) {
    return result;
  }
  if (stores.__dynamic == null) {
    return cb(new Error('Unknown queries'));
  }
  result.push({
    __query: '__dynamic',
    keys: Object.keys(query.unknown),
    query: function(cb) {
      return stores.__dynamic(query.unknown, cb);
    },
    queries: query.unknown
  });
  return result;
};



},{"./split":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/split.coffee"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/desc.coffee":[function(require,module,exports){
module.exports = function(query) {
  if (Object.keys(query).length === 0) {
    return '-- no query --';
  }
  return 'query\n' + Object.keys(query).map(function(prop) {
    return "  " + prop + " from " + query[prop].__query;
  }).join('\n');
};



},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/diff.coffee":[function(require,module,exports){
var diffisdelete, jsondiffpatch;

jsondiffpatch = require('jsondiffpatch');

diffisdelete = function(diff) {
  return diff instanceof Array && diff.length === 3 && diff[1] === 0 && diff[2] === 0;
};

module.exports = function(prev, next) {
  var diff, key, result, value;
  result = {};
  diff = jsondiffpatch.diff(prev, next);
  for (key in diff) {
    value = diff[key];
    if (diffisdelete(value)) {
      continue;
    }
    result[key] = next[key];
  }
  for (key in next) {
    value = next[key];
    if ((value != null ? value.__fresh : void 0) != null) {
      result[key] = value;
    }
  }
  return result;
};



},{"jsondiffpatch":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/main.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/exec.coffee":[function(require,module,exports){
var async, build, extend;

build = require('./build');

async = require('odo-async');

extend = require('extend');

module.exports = function(query, stores, callback) {
  var errors, fn, i, len, q, state, tasks;
  query = build(query, stores);
  errors = [];
  tasks = [];
  state = {};
  fn = function(q) {
    return tasks.push(function(cb) {
      return q.query(function(err, results) {
        if (err != null) {
          errors.push(err);
        } else {
          extend(state, results);
        }
        return cb();
      });
    });
  };
  for (i = 0, len = query.length; i < len; i++) {
    q = query[i];
    fn(q);
  }
  return async.parallel(tasks, function() {
    if (errors.length !== 0) {
      return callback(errors, state);
    }
    return callback(null, state);
  });
};



},{"./build":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/build.coffee","extend":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/extend/index.js","odo-async":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/odo-async/async.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/merge.coffee":[function(require,module,exports){
var eq, extend, merge;

extend = require('extend');

eq = function(a, b) {
  var aarray, akeys, barray, bkeys, i, j, key, ref, value;
  if (a === b) {
    return true;
  }
  if (typeof a !== 'object' || typeof b !== 'object') {
    return false;
  }
  if (a === null || b === null) {
    return false;
  }
  aarray = a instanceof Array;
  barray = b instanceof Array;
  if (aarray !== barray) {
    return false;
  }
  if (aarray) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = j = 0, ref = a.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      if (!eq(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  akeys = Object.keys(a);
  bkeys = Object.keys(b);
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (key in a) {
    value = a[key];
    if (!eq(value, b[key])) {
      return false;
    }
  }
  return true;
};

merge = function(base, extra) {
  var aarray, barray, key, results, value;
  aarray = base instanceof Array;
  barray = extra instanceof Array;
  if (aarray) {
    if (!barray) {
      console.log('Not an array, ignoring');
      console.log(extra);
      return base;
    }
    if (base.length !== 1 || extra.length !== 1) {
      console.log('Expecting length 1 arrays');
      console.log(extra);
      return base;
    }
    return [merge(base[0], extra[0])];
  }
  if (base.__query != null) {
    if (extra.__query == null) {
      console.log('Non query, ignoring');
      console.log(extra);
      return base;
    }
    if (!eq(base.__params, extra.__params)) {
      console.log('Query does not match, ignoring');
      console.log(extra);
      return base;
    }
    if ((base.__shape == null) || (extra.__shape == null)) {
      return base;
    }
    merge(base.__shape, extra.__shape);
    return;
  } else if (extra.__query != null) {
    console.log('Query, ignoring');
    console.log(extra);
    return base;
  }
  results = [];
  for (key in extra) {
    value = extra[key];
    if ((base[key] != null) && typeof value === 'object') {
      merge(base[key], value);
      continue;
    }
    results.push(base[key] = value);
  }
  return results;
};

module.exports = function(queries) {
  var j, len, query, result;
  if (arguments.length === 0) {
    return null;
  }
  if (arguments.length !== 1) {
    queries = Array.prototype.slice.call(arguments, 0);
  }
  if (queries.length === 0) {
    return null;
  }
  result = {};
  for (j = 0, len = queries.length; j < len; j++) {
    query = queries[j];
    merge(result, extend({}, query));
  }
  return result;
};



},{"extend":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/extend/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql/split.coffee":[function(require,module,exports){
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(query, names) {
  var key, known, ref, unknown, value;
  known = {};
  unknown = {};
  for (key in query) {
    value = query[key];
    if (ref = value.__query, indexOf.call(names, ref) >= 0) {
      known[key] = value;
    } else {
      unknown[key] = value;
    }
  }
  return {
    known: known,
    unknown: unknown
  };
};



},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/parallelqueries.coffee":[function(require,module,exports){
module.exports = function(max, idle) {
  var _batch, _queued, _running, next, result, start;
  _batch = {};
  _running = [];
  _queued = [];
  start = function(entry) {
    var cancel;
    entry.startedAt = new Date().getTime();
    cancel = entry.task(function(err, cb) {
      var fin, i, index, key, len, ref;
      index = _running.indexOf(entry);
      _running.splice(index, 1);
      if (err == null) {
        fin = new Date().getTime();
        ref = entry.keys;
        for (i = 0, len = ref.length; i < len; i++) {
          key = ref[i];
          _batch[key] = fin - entry.startedAt;
        }
        cb(entry.keys);
      }
      return next();
    });
    if (_running.indexOf(entry) === -1) {
      return;
    }
    if (typeof cancel !== 'function') {
      cancel = function() {};
    }
    entry.cancel = cancel;
    return next();
  };
  next = function() {
    if ((idle != null) && _running.length === 0 && _queued.length === 0) {
      idle(_batch);
      _batch = {};
      return;
    }
    if (_queued.length === 0) {
      return;
    }
    if (_running.length >= max) {
      return;
    }
    return start(_queued.shift());
  };
  return result = {
    cancel: function(keys) {
      _queued = _queued.filter(function(entry) {
        entry.keys = entry.keys.filter(function(key) {
          return keys.indexOf(key) === -1;
        });
        if (entry.keys.length !== 0) {
          return true;
        }
        return false;
      });
      return _running = _running.filter(function(entry) {
        entry.keys = entry.keys.filter(function(key) {
          return keys.indexOf(key) === -1;
        });
        if (entry.keys.length !== 0) {
          return true;
        }
        entry.cancel();
        return false;
      });
    },
    add: function(keys, task) {
      var entry;
      entry = {
        keys: keys,
        task: task
      };
      result.cancel(keys);
      return _queued.push(entry);
    },
    exec: function() {
      return next();
    }
  };
};



},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/relay.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var async, extend, layers, parallelqueries, ql;

extend = require('extend');

parallelqueries = require('./parallelqueries');

ql = require('odoql/ql');

layers = require('./layers');

async = require('odo-async');

module.exports = function(el, component, stores) {
  var Relay, _layers, _memory, _query, _scene, _state, pq, update;
  _scene = null;
  _memory = {};
  _query = {};
  _state = layers();
  _layers = [];
  update = function() {
    if (_scene == null) {
      Relay.mount();
      return;
    }
    return _scene.update(_state.get(), _memory);
  };
  pq = parallelqueries(5, function(timings) {
    var _, _timings, key;
    if ((typeof window !== "undefined" && window !== null ? window.hub : void 0) != null) {
      _timings = {};
      for (key in timings) {
        _ = timings[key];
        _timings[key] = timings[key];
      }
      window.hub.emit('queries completed', _timings);
    }
    return update();
  });
  Relay = {
    mount: function() {
      return _scene = component.mount(el, _state.get(), _memory);
    },
    update: function(params) {
      var diff, newquery;
      extend(_memory, params);
      newquery = component.query(_memory);
      diff = ql.diff(_query, newquery);
      _query = newquery;
      if (Object.keys(diff).length === 0) {
        return update();
      }
      if ((typeof window !== "undefined" && window !== null ? window.hub : void 0) != null) {
        window.hub.emit('queries starting', {
          diff: diff,
          description: ql.desc(diff)
        });
      }
      return async.delay(function() {
        var fn, i, len, q;
        diff = ql.build(diff, stores);
        fn = function(q) {
          return pq.add(q.keys, function(cb) {
            return q.query(function(err, results) {
              if ((err != null) && ((typeof window !== "undefined" && window !== null ? window.hub : void 0) != null)) {
                window.hub.emit('query error {err}', {
                  err: err
                });
              }
              return cb(err, function(keys) {
                var j, key, len1, updates;
                updates = {};
                for (j = 0, len1 = keys.length; j < len1; j++) {
                  key = keys[j];
                  updates[key] = results[key];
                }
                return _state.apply(updates);
              });
            });
          });
        };
        for (i = 0, len = diff.length; i < len; i++) {
          q = diff[i];
          fn(q);
        }
        return pq.exec();
      });
    },
    layer: _state.layer,
    params: function() {
      return _memory;
    },
    state: function() {
      return _state.get();
    },
    unmount: function() {
      _scene.unmount();
      return _scene = null;
    }
  };
  return Relay;
};

},{"./layers":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/layers.coffee","./parallelqueries":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/parallelqueries.coffee","extend":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/extend/index.js","odo-async":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odo-async/async.js","odoql/ql":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/ql.coffee"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/component.coffee":[function(require,module,exports){
var component, extend;

extend = require('extend');

component = function(spec) {
  var Component, i, len, plugin, ref;
  spec = extend({}, spec);
  Component = function(state, params) {
    return spec.render.call(spec, state, params);
  };
  Component.use = function(plugin) {
    return plugin(Component, spec);
  };
  ref = component.plugins;
  for (i = 0, len = ref.length; i < len; i++) {
    plugin = ref[i];
    Component.use(plugin);
  }
  return Component;
};

component.plugins = [];

component.use = function(plugin) {
  return component.plugins.push(plugin);
};

module.exports = component;



},{"extend":"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/compose.coffee":[function(require,module,exports){
var VText, create, diff, patch, raf, time;

create = require('virtual-dom/create-element');

diff = require('virtual-dom/diff');

patch = require('virtual-dom/patch');

VText = require('virtual-dom/vnode/vtext');

raf = require('raf');

time = function(description, cb) {
  var endedAt, startedAt;
  startedAt = new Date().getTime();
  cb();
  endedAt = new Date().getTime();
  if ((typeof window !== "undefined" && window !== null ? window.hub : void 0) != null) {
    return window.hub.emit('{description} in {duration}ms', {
      description: description,
      startedAt: startedAt,
      endedAt: endedAt,
      duration: endedAt - startedAt
    });
  }
};

module.exports = function(component, state, params, parent) {
  var apply, payload, status, target, tree;
  status = 'init';
  tree = null;
  target = null;
  time('scene created', function() {
    tree = component(state, params);
    return target = create(tree);
  });
  status = 'idle';
  apply = function(state, params) {
    if (status === 'rendering') {
      throw new Error('Mutant rampage');
    }
    status = 'rendering';
    time('scene updated', function() {
      var newTree, patches;
      newTree = component(state, params);
      patches = diff(tree, newTree);
      target = patch(target, patches);
      return tree = newTree;
    });
    return status = 'idle';
  };
  payload = null;
  return {
    target: target,
    status: status,
    mount: function() {
      return parent.appendChild(target);
    },
    update: function(state, params) {
      if (status === 'rendering') {
        throw new Error('Mutant rampage');
      }
      if (status === 'pending') {
        payload = {
          state: state,
          params: params
        };
        return;
      }
      if (status === 'idle') {
        status = 'pending';
        payload = {
          state: state,
          params: params
        };
        return raf(function() {
          if (payload === null) {
            return;
          }
          apply(payload.state, payload.params);
          return payload = null;
        });
      }
    },
    apply: apply,
    unmount: function() {
      return patch(target, diff(tree, new VText('')));
    }
  };
};



},{"raf":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/raf/index.js","virtual-dom/create-element":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/create-element.js","virtual-dom/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/diff.js","virtual-dom/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/patch.js","virtual-dom/vnode/vtext":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vtext.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/hook.coffee":[function(require,module,exports){
var Hook, compose, create, dom, extend, hook;

create = require('virtual-dom/create-element');

compose = require('./compose');

extend = require('extend');

dom = require('virtual-dom/h');

require('setimmediate');

Hook = (function() {
  function Hook(component1, spec1, state1, params1) {
    this.component = component1;
    this.spec = spec1;
    this.state = state1;
    this.params = params1;
    if (this.spec.enter == null) {
      this.spec.enter = function(item) {
        return this.item.mount();
      };
    }
    if (this.spec.exit == null) {
      this.spec.exit = function(item) {
        return this.item.unmount();
      };
    }
    if (this.spec.transition == null) {
      this.spec.transition = function(olditem, newitem) {
        olditem.unmount();
        return item.mount();
      };
    }
  }

  Hook.prototype.type = 'Widget';

  Hook.prototype.create = function() {
    this.item = compose(this.component, this.state, this.params, this.el);
    return this.spec.enter.call(this.spec, this.item, this.state, this.params);
  };

  Hook.prototype.remove = function() {
    return this.spec.exit.call(this.spec, this.item, this.state, this.params);
  };

  Hook.prototype.init = function() {
    this.el = create(dom('div'));
    setImmediate((function(_this) {
      return function() {
        return _this.create();
      };
    })(this));
    return this.el;
  };

  Hook.prototype.update = function(prev, el) {
    var olditem;
    this.el = prev.el, this.item = prev.item;
    if (prev.component === this.component) {
      if (this.component == null) {
        return el;
      }
      return el(this.item.update(this.state, this.params));
    }
    if (prev.component == null) {
      this.create();
      return el;
    }
    if (this.component == null) {
      this.remove();
      return el;
    }
    olditem = this.item;
    this.item = compose(this.component, this.state, this.params, el);
    this.spec.transition.call(this.spec, olditem, this.item, this.state, this.params);
    return el;
  };

  Hook.prototype.destroy = function() {
    return this.remove();
  };

  return Hook;

})();

hook = function(spec) {
  var Component, i, len, plugin, ref;
  spec = extend({}, spec);
  Component = function(component, state, params) {
    return new Hook(component, spec, state, params);
  };
  Component.use = function(plugin) {
    return plugin(Component, spec);
  };
  ref = hook.plugins;
  for (i = 0, len = ref.length; i < len; i++) {
    plugin = ref[i];
    Component.use(plugin);
  }
  return Component;
};

hook.plugins = [];

hook.use = function(plugin) {
  return hook.plugins.push(plugin);
};

module.exports = hook;



},{"./compose":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/compose.coffee","extend":"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js","setimmediate":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/setimmediate/setImmediate.js","virtual-dom/create-element":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/create-element.js","virtual-dom/h":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/h.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/mount.coffee":[function(require,module,exports){
var compose;

compose = require('./compose');

module.exports = function(component, spec) {
  return component.mount = function(el, state, params) {
    var scene;
    scene = compose(component, state, params, el);
    scene.mount();
    return {
      update: function(state, params) {
        return scene.update(state, params);
      },
      apply: function(state, params) {
        return scene.apply(state, params);
      },
      unmount: function() {
        return scene.unmount();
      }
    };
  };
};



},{"./compose":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/compose.coffee"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/raf/index.js":[function(require,module,exports){
var now = require('performance-now')
  , global = typeof window === 'undefined' ? {} : window
  , vendors = ['moz', 'webkit']
  , suffix = 'AnimationFrame'
  , raf = global['request' + suffix]
  , caf = global['cancel' + suffix] || global['cancelRequest' + suffix]
  , isNative = true

for(var i = 0; i < vendors.length && !raf; i++) {
  raf = global[vendors[i] + 'Request' + suffix]
  caf = global[vendors[i] + 'Cancel' + suffix]
      || global[vendors[i] + 'CancelRequest' + suffix]
}

// Some versions of FF have rAF but not cAF
if(!raf || !caf) {
  isNative = false

  var last = 0
    , id = 0
    , queue = []
    , frameDuration = 1000 / 60

  raf = function(callback) {
    if(queue.length === 0) {
      var _now = now()
        , next = Math.max(0, frameDuration - (_now - last))
      last = next + _now
      setTimeout(function() {
        var cp = queue.slice(0)
        // Clear queue here to prevent
        // callbacks from appending listeners
        // to the current frame's queue
        queue.length = 0
        for(var i = 0; i < cp.length; i++) {
          if(!cp[i].cancelled) {
            try{
              cp[i].callback(last)
            } catch(e) {
              setTimeout(function() { throw e }, 0)
            }
          }
        }
      }, Math.round(next))
    }
    queue.push({
      handle: ++id,
      callback: callback,
      cancelled: false
    })
    return id
  }

  caf = function(handle) {
    for(var i = 0; i < queue.length; i++) {
      if(queue[i].handle === handle) {
        queue[i].cancelled = true
      }
    }
  }
}

module.exports = function(fn) {
  // Wrap in a new function to prevent
  // `cancel` potentially being assigned
  // to the native rAF function
  if(!isNative) {
    return raf.call(global, fn)
  }
  return raf.call(global, function() {
    try{
      fn.apply(this, arguments)
    } catch(e) {
      setTimeout(function() { throw e }, 0)
    }
  })
}
module.exports.cancel = function() {
  caf.apply(global, arguments)
}

},{"performance-now":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/raf/node_modules/performance-now/lib/performance-now.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/raf/node_modules/performance-now/lib/performance-now.js":[function(require,module,exports){
(function (process){
// Generated by CoffeeScript 1.6.3
(function() {
  var getNanoSeconds, hrtime, loadTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - loadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    loadTime = getNanoSeconds();
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(this);

/*
//@ sourceMappingURL=performance-now.map
*/

}).call(this,require('_process'))

},{"_process":"/Users/tcoats/Mayhem/wedding/node_modules/browserify/node_modules/process/browser.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/setimmediate/setImmediate.js":[function(require,module,exports){
(function (process){
(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var setImmediate;

    function addFromSetImmediateArguments(args) {
        tasksByHandle[nextHandle] = partiallyApplied.apply(undefined, args);
        return nextHandle++;
    }

    // This function accepts the same arguments as setImmediate, but
    // returns a function that requires no arguments.
    function partiallyApplied(handler) {
        var args = [].slice.call(arguments, 1);
        return function() {
            if (typeof handler === "function") {
                handler.apply(undefined, args);
            } else {
                (new Function("" + handler))();
            }
        };
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    task();
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function installNextTickImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            process.nextTick(partiallyApplied(runIfPresent, handle));
            return handle;
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            global.postMessage(messagePrefix + handle, "*");
            return handle;
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            channel.port2.postMessage(handle);
            return handle;
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
            return handle;
        };
    }

    function installSetTimeoutImplementation() {
        setImmediate = function() {
            var handle = addFromSetImmediateArguments(arguments);
            setTimeout(partiallyApplied(runIfPresent, handle), 0);
            return handle;
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(new Function("return this")()));

}).call(this,require('_process'))

},{"_process":"/Users/tcoats/Mayhem/wedding/node_modules/browserify/node_modules/process/browser.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/immutable-thunk.js":[function(require,module,exports){
function Thunk(fn, args, key, eqArgs) {
    this.fn = fn;
    this.args = args;
    this.key = key;
    this.eqArgs = eqArgs;
}

Thunk.prototype.type = 'Thunk';
Thunk.prototype.render = render;
module.exports = Thunk;

function shouldUpdate(current, previous) {
    if (!current || !previous || current.fn !== previous.fn) {
        return true;
    }

    var cargs = current.args;
    var pargs = previous.args;

    return !current.eqArgs(cargs, pargs);
}

function render(previous) {
    if (shouldUpdate(this, previous)) {
        return this.fn.apply(null, this.args);
    } else {
        return previous.vnode;
    }
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/index.js":[function(require,module,exports){
var Partial = require('./partial');

module.exports = Partial();

},{"./partial":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/partial.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/partial.js":[function(require,module,exports){
var shallowEq = require('./shallow-eq');
var Thunk = require('./immutable-thunk');

module.exports = createPartial;

function createPartial(eq) {
    return function partial(fn) {
        var args = copyOver(arguments, 1);
        var firstArg = args[0];
        var key;

        var eqArgs = eq || shallowEq;

        if (typeof firstArg === 'object' && firstArg !== null) {
            if ('key' in firstArg) {
                key = firstArg.key;
            } else if ('id' in firstArg) {
                key = firstArg.id;
            }
        }

        return new Thunk(fn, args, key, eqArgs);
    };
}

function copyOver(list, offset) {
    var newList = [];
    for (var i = list.length - 1; i >= offset; i--) {
        newList[i - offset] = list[i];
    }
    return newList;
}

},{"./immutable-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/immutable-thunk.js","./shallow-eq":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/shallow-eq.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/shallow-eq.js":[function(require,module,exports){
module.exports = shallowEq;

function shallowEq(currentArgs, previousArgs) {
    if (currentArgs.length === 0 && previousArgs.length === 0) {
        return true;
    }

    if (currentArgs.length !== previousArgs.length) {
        return false;
    }

    var len = currentArgs.length;

    for (var i = 0; i < len; i++) {
        if (currentArgs[i] !== previousArgs[i]) {
            return false;
        }
    }

    return true;
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/create-attribute.js":[function(require,module,exports){
var escape = require('escape-html');
var propConfig = require('./property-config');
var types = propConfig.attributeTypes;
var properties = propConfig.properties;
var attributeNames = propConfig.attributeNames;

var prefixAttribute = memoizeString(function (name) {
  return escape(name) + '="';
});

module.exports = createAttribute;

/**
 * Create attribute string.
 *
 * @param {String} name The name of the property or attribute
 * @param {*} value The value
 * @param {Boolean} [isAttribute] Denotes whether `name` is an attribute.
 * @return {?String} Attribute string || null if not a valid property or custom attribute.
 */

function createAttribute(name, value, isAttribute) {
  var attrType = properties[name];
  if (attrType) {
    if (shouldSkip(name, value)) return '';
    name = (attributeNames[name] || name).toLowerCase();
    // for BOOLEAN `value` only has to be truthy
    // for OVERLOADED_BOOLEAN `value` has to be === true
    if ((attrType === types.BOOLEAN) ||
        (attrType === types.OVERLOADED_BOOLEAN && value === true)) {
      return escape(name);
    }
    return prefixAttribute(name) + escape(value) + '"';
  } else if (isAttribute) {
    if (value == null) return '';
    return prefixAttribute(name) + escape(value) + '"';
  }
  // return null if `name` is neither a valid property nor an attribute
  return null;
}

/**
 * Should skip false boolean attributes.
 */

function shouldSkip(name, value) {
  var attrType = properties[name];
  return value == null ||
    (attrType === types.BOOLEAN && !value) ||
    (attrType === types.OVERLOADED_BOOLEAN && value === false);
}

/**
 * Memoizes the return value of a function that accepts one string argument.
 *
 * @param {function} callback
 * @return {function}
 */

function memoizeString(callback) {
  var cache = {};
  return function(string) {
    if (cache.hasOwnProperty(string)) {
      return cache[string];
    } else {
      return cache[string] = callback.call(this, string);
    }
  };
}
},{"./property-config":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/property-config.js","escape-html":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/escape-html/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/index.js":[function(require,module,exports){
var escape = require('escape-html');
var extend = require('xtend');
var isVNode = require('virtual-dom/vnode/is-vnode');
var isVText = require('virtual-dom/vnode/is-vtext');
var isThunk = require('virtual-dom/vnode/is-thunk');
var softHook = require('virtual-dom/virtual-hyperscript/hooks/soft-set-hook');
var attrHook = require('virtual-dom/virtual-hyperscript/hooks/attribute-hook');
var paramCase = require('param-case');
var createAttribute = require('./create-attribute');
var voidElements = require('./void-elements');

module.exports = toHTML;

function toHTML(node, parent) {
  if (!node) return '';

  if (isThunk(node)) {
    node = node.render();
  }

  if (isVNode(node)) {
    return openTag(node) + tagContent(node) + closeTag(node);
  } else if (isVText(node)) {
    if (parent && parent.tagName.toLowerCase() === 'script') return String(node.text);
    return escape(String(node.text));
  }

  return '';
}

function openTag(node) {
  var props = node.properties;
  var ret = '<' + node.tagName.toLowerCase();

  for (var name in props) {
    var value = props[name];
    if (value == null) continue;

    if (name == 'attributes') {
      value = extend({}, value);
      for (var attrProp in value) {
        ret += ' ' + createAttribute(attrProp, value[attrProp], true);
      }
      continue;
    }

    if (name == 'style') {
      var css = '';
      value = extend({}, value);
      for (var styleProp in value) {
        css += paramCase(styleProp) + ': ' + value[styleProp] + '; ';
      }
      value = css.trim();
    }

    if (value instanceof softHook || value instanceof attrHook) {
      ret += ' ' + createAttribute(name, value.value, true);
      continue;
    }

    var attr = createAttribute(name, value);
    if (attr) ret += ' ' + attr;
  }

  return ret + '>';
}

function tagContent(node) {
  var innerHTML = node.properties.innerHTML;
  if (innerHTML != null) return innerHTML;
  else {
    var ret = '';
    if (node.children && node.children.length) {
      for (var i = 0, l = node.children.length; i<l; i++) {
        var child = node.children[i];
        ret += toHTML(child, node);
      }
    }
    return ret;
  }
}

function closeTag(node) {
  var tag = node.tagName.toLowerCase();
  return voidElements[tag] ? '' : '</' + tag + '>';
}
},{"./create-attribute":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/create-attribute.js","./void-elements":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/void-elements.js","escape-html":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/escape-html/index.js","param-case":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/param-case.js","virtual-dom/virtual-hyperscript/hooks/attribute-hook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/attribute-hook.js","virtual-dom/virtual-hyperscript/hooks/soft-set-hook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","virtual-dom/vnode/is-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-thunk.js","virtual-dom/vnode/is-vnode":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vnode.js","virtual-dom/vnode/is-vtext":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vtext.js","xtend":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/xtend/immutable.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/escape-html/index.js":[function(require,module,exports){
/**
 * Escape special characters in the given string of html.
 *
 * @param  {String} html
 * @return {String}
 * @api private
 */

module.exports = function(html) {
  return String(html)
    .replace(/&/g, '&amp;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;');
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/node_modules/lower-case/lower-case.js":[function(require,module,exports){
/**
 * Special language-specific overrides.
 *
 * Source: ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt
 *
 * @type {Object}
 */
var LANGUAGES = {
  tr: {
    regexp: /\u0130|\u0049|\u0049\u0307/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  az: {
    regexp: /[\u0130]/g,
    map: {
      '\u0130': '\u0069',
      '\u0049': '\u0131',
      '\u0049\u0307': '\u0069'
    }
  },
  lt: {
    regexp: /[\u0049\u004A\u012E\u00CC\u00CD\u0128]/g,
    map: {
      '\u0049': '\u0069\u0307',
      '\u004A': '\u006A\u0307',
      '\u012E': '\u012F\u0307',
      '\u00CC': '\u0069\u0307\u0300',
      '\u00CD': '\u0069\u0307\u0301',
      '\u0128': '\u0069\u0307\u0303'
    }
  }
}

/**
 * Lowercase a string.
 *
 * @param  {String} str
 * @return {String}
 */
module.exports = function (str, locale) {
  var lang = LANGUAGES[locale]

  str = str == null ? '' : String(str)

  if (lang) {
    str = str.replace(lang.regexp, function (m) { return lang.map[m] })
  }

  return str.toLowerCase()
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/sentence-case.js":[function(require,module,exports){
var lowerCase = require('lower-case')

var NON_WORD_REGEXP = require('./vendor/non-word-regexp')
var CAMEL_CASE_REGEXP = require('./vendor/camel-case-regexp')
var TRAILING_DIGIT_REGEXP = require('./vendor/trailing-digit-regexp')

/**
 * Sentence case a string.
 *
 * @param  {String} str
 * @param  {String} locale
 * @param  {String} replacement
 * @return {String}
 */
module.exports = function (str, locale, replacement) {
  if (str == null) {
    return ''
  }

  replacement = replacement || ' '

  function replace (match, index, string) {
    if (index === 0 || index === (string.length - match.length)) {
      return ''
    }

    return replacement
  }

  str = String(str)
    // Support camel case ("camelCase" -> "camel Case").
    .replace(CAMEL_CASE_REGEXP, '$1 $2')
    // Support digit groups ("test2012" -> "test 2012").
    .replace(TRAILING_DIGIT_REGEXP, '$1 $2')
    // Remove all non-word characters and replace with a single space.
    .replace(NON_WORD_REGEXP, replace)

  // Lower case the entire string.
  return lowerCase(str, locale)
}

},{"./vendor/camel-case-regexp":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/camel-case-regexp.js","./vendor/non-word-regexp":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/non-word-regexp.js","./vendor/trailing-digit-regexp":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/trailing-digit-regexp.js","lower-case":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/node_modules/lower-case/lower-case.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/camel-case-regexp.js":[function(require,module,exports){
module.exports = /([\u0061-\u007A\u00B5\u00DF-\u00F6\u00F8-\u00FF\u0101\u0103\u0105\u0107\u0109\u010B\u010D\u010F\u0111\u0113\u0115\u0117\u0119\u011B\u011D\u011F\u0121\u0123\u0125\u0127\u0129\u012B\u012D\u012F\u0131\u0133\u0135\u0137\u0138\u013A\u013C\u013E\u0140\u0142\u0144\u0146\u0148\u0149\u014B\u014D\u014F\u0151\u0153\u0155\u0157\u0159\u015B\u015D\u015F\u0161\u0163\u0165\u0167\u0169\u016B\u016D\u016F\u0171\u0173\u0175\u0177\u017A\u017C\u017E-\u0180\u0183\u0185\u0188\u018C\u018D\u0192\u0195\u0199-\u019B\u019E\u01A1\u01A3\u01A5\u01A8\u01AA\u01AB\u01AD\u01B0\u01B4\u01B6\u01B9\u01BA\u01BD-\u01BF\u01C6\u01C9\u01CC\u01CE\u01D0\u01D2\u01D4\u01D6\u01D8\u01DA\u01DC\u01DD\u01DF\u01E1\u01E3\u01E5\u01E7\u01E9\u01EB\u01ED\u01EF\u01F0\u01F3\u01F5\u01F9\u01FB\u01FD\u01FF\u0201\u0203\u0205\u0207\u0209\u020B\u020D\u020F\u0211\u0213\u0215\u0217\u0219\u021B\u021D\u021F\u0221\u0223\u0225\u0227\u0229\u022B\u022D\u022F\u0231\u0233-\u0239\u023C\u023F\u0240\u0242\u0247\u0249\u024B\u024D\u024F-\u0293\u0295-\u02AF\u0371\u0373\u0377\u037B-\u037D\u0390\u03AC-\u03CE\u03D0\u03D1\u03D5-\u03D7\u03D9\u03DB\u03DD\u03DF\u03E1\u03E3\u03E5\u03E7\u03E9\u03EB\u03ED\u03EF-\u03F3\u03F5\u03F8\u03FB\u03FC\u0430-\u045F\u0461\u0463\u0465\u0467\u0469\u046B\u046D\u046F\u0471\u0473\u0475\u0477\u0479\u047B\u047D\u047F\u0481\u048B\u048D\u048F\u0491\u0493\u0495\u0497\u0499\u049B\u049D\u049F\u04A1\u04A3\u04A5\u04A7\u04A9\u04AB\u04AD\u04AF\u04B1\u04B3\u04B5\u04B7\u04B9\u04BB\u04BD\u04BF\u04C2\u04C4\u04C6\u04C8\u04CA\u04CC\u04CE\u04CF\u04D1\u04D3\u04D5\u04D7\u04D9\u04DB\u04DD\u04DF\u04E1\u04E3\u04E5\u04E7\u04E9\u04EB\u04ED\u04EF\u04F1\u04F3\u04F5\u04F7\u04F9\u04FB\u04FD\u04FF\u0501\u0503\u0505\u0507\u0509\u050B\u050D\u050F\u0511\u0513\u0515\u0517\u0519\u051B\u051D\u051F\u0521\u0523\u0525\u0527\u0561-\u0587\u1D00-\u1D2B\u1D6B-\u1D77\u1D79-\u1D9A\u1E01\u1E03\u1E05\u1E07\u1E09\u1E0B\u1E0D\u1E0F\u1E11\u1E13\u1E15\u1E17\u1E19\u1E1B\u1E1D\u1E1F\u1E21\u1E23\u1E25\u1E27\u1E29\u1E2B\u1E2D\u1E2F\u1E31\u1E33\u1E35\u1E37\u1E39\u1E3B\u1E3D\u1E3F\u1E41\u1E43\u1E45\u1E47\u1E49\u1E4B\u1E4D\u1E4F\u1E51\u1E53\u1E55\u1E57\u1E59\u1E5B\u1E5D\u1E5F\u1E61\u1E63\u1E65\u1E67\u1E69\u1E6B\u1E6D\u1E6F\u1E71\u1E73\u1E75\u1E77\u1E79\u1E7B\u1E7D\u1E7F\u1E81\u1E83\u1E85\u1E87\u1E89\u1E8B\u1E8D\u1E8F\u1E91\u1E93\u1E95-\u1E9D\u1E9F\u1EA1\u1EA3\u1EA5\u1EA7\u1EA9\u1EAB\u1EAD\u1EAF\u1EB1\u1EB3\u1EB5\u1EB7\u1EB9\u1EBB\u1EBD\u1EBF\u1EC1\u1EC3\u1EC5\u1EC7\u1EC9\u1ECB\u1ECD\u1ECF\u1ED1\u1ED3\u1ED5\u1ED7\u1ED9\u1EDB\u1EDD\u1EDF\u1EE1\u1EE3\u1EE5\u1EE7\u1EE9\u1EEB\u1EED\u1EEF\u1EF1\u1EF3\u1EF5\u1EF7\u1EF9\u1EFB\u1EFD\u1EFF-\u1F07\u1F10-\u1F15\u1F20-\u1F27\u1F30-\u1F37\u1F40-\u1F45\u1F50-\u1F57\u1F60-\u1F67\u1F70-\u1F7D\u1F80-\u1F87\u1F90-\u1F97\u1FA0-\u1FA7\u1FB0-\u1FB4\u1FB6\u1FB7\u1FBE\u1FC2-\u1FC4\u1FC6\u1FC7\u1FD0-\u1FD3\u1FD6\u1FD7\u1FE0-\u1FE7\u1FF2-\u1FF4\u1FF6\u1FF7\u210A\u210E\u210F\u2113\u212F\u2134\u2139\u213C\u213D\u2146-\u2149\u214E\u2184\u2C30-\u2C5E\u2C61\u2C65\u2C66\u2C68\u2C6A\u2C6C\u2C71\u2C73\u2C74\u2C76-\u2C7B\u2C81\u2C83\u2C85\u2C87\u2C89\u2C8B\u2C8D\u2C8F\u2C91\u2C93\u2C95\u2C97\u2C99\u2C9B\u2C9D\u2C9F\u2CA1\u2CA3\u2CA5\u2CA7\u2CA9\u2CAB\u2CAD\u2CAF\u2CB1\u2CB3\u2CB5\u2CB7\u2CB9\u2CBB\u2CBD\u2CBF\u2CC1\u2CC3\u2CC5\u2CC7\u2CC9\u2CCB\u2CCD\u2CCF\u2CD1\u2CD3\u2CD5\u2CD7\u2CD9\u2CDB\u2CDD\u2CDF\u2CE1\u2CE3\u2CE4\u2CEC\u2CEE\u2CF3\u2D00-\u2D25\u2D27\u2D2D\uA641\uA643\uA645\uA647\uA649\uA64B\uA64D\uA64F\uA651\uA653\uA655\uA657\uA659\uA65B\uA65D\uA65F\uA661\uA663\uA665\uA667\uA669\uA66B\uA66D\uA681\uA683\uA685\uA687\uA689\uA68B\uA68D\uA68F\uA691\uA693\uA695\uA697\uA723\uA725\uA727\uA729\uA72B\uA72D\uA72F-\uA731\uA733\uA735\uA737\uA739\uA73B\uA73D\uA73F\uA741\uA743\uA745\uA747\uA749\uA74B\uA74D\uA74F\uA751\uA753\uA755\uA757\uA759\uA75B\uA75D\uA75F\uA761\uA763\uA765\uA767\uA769\uA76B\uA76D\uA76F\uA771-\uA778\uA77A\uA77C\uA77F\uA781\uA783\uA785\uA787\uA78C\uA78E\uA791\uA793\uA7A1\uA7A3\uA7A5\uA7A7\uA7A9\uA7FA\uFB00-\uFB06\uFB13-\uFB17\uFF41-\uFF5A])([\u0041-\u005A\u00C0-\u00D6\u00D8-\u00DE\u0100\u0102\u0104\u0106\u0108\u010A\u010C\u010E\u0110\u0112\u0114\u0116\u0118\u011A\u011C\u011E\u0120\u0122\u0124\u0126\u0128\u012A\u012C\u012E\u0130\u0132\u0134\u0136\u0139\u013B\u013D\u013F\u0141\u0143\u0145\u0147\u014A\u014C\u014E\u0150\u0152\u0154\u0156\u0158\u015A\u015C\u015E\u0160\u0162\u0164\u0166\u0168\u016A\u016C\u016E\u0170\u0172\u0174\u0176\u0178\u0179\u017B\u017D\u0181\u0182\u0184\u0186\u0187\u0189-\u018B\u018E-\u0191\u0193\u0194\u0196-\u0198\u019C\u019D\u019F\u01A0\u01A2\u01A4\u01A6\u01A7\u01A9\u01AC\u01AE\u01AF\u01B1-\u01B3\u01B5\u01B7\u01B8\u01BC\u01C4\u01C7\u01CA\u01CD\u01CF\u01D1\u01D3\u01D5\u01D7\u01D9\u01DB\u01DE\u01E0\u01E2\u01E4\u01E6\u01E8\u01EA\u01EC\u01EE\u01F1\u01F4\u01F6-\u01F8\u01FA\u01FC\u01FE\u0200\u0202\u0204\u0206\u0208\u020A\u020C\u020E\u0210\u0212\u0214\u0216\u0218\u021A\u021C\u021E\u0220\u0222\u0224\u0226\u0228\u022A\u022C\u022E\u0230\u0232\u023A\u023B\u023D\u023E\u0241\u0243-\u0246\u0248\u024A\u024C\u024E\u0370\u0372\u0376\u0386\u0388-\u038A\u038C\u038E\u038F\u0391-\u03A1\u03A3-\u03AB\u03CF\u03D2-\u03D4\u03D8\u03DA\u03DC\u03DE\u03E0\u03E2\u03E4\u03E6\u03E8\u03EA\u03EC\u03EE\u03F4\u03F7\u03F9\u03FA\u03FD-\u042F\u0460\u0462\u0464\u0466\u0468\u046A\u046C\u046E\u0470\u0472\u0474\u0476\u0478\u047A\u047C\u047E\u0480\u048A\u048C\u048E\u0490\u0492\u0494\u0496\u0498\u049A\u049C\u049E\u04A0\u04A2\u04A4\u04A6\u04A8\u04AA\u04AC\u04AE\u04B0\u04B2\u04B4\u04B6\u04B8\u04BA\u04BC\u04BE\u04C0\u04C1\u04C3\u04C5\u04C7\u04C9\u04CB\u04CD\u04D0\u04D2\u04D4\u04D6\u04D8\u04DA\u04DC\u04DE\u04E0\u04E2\u04E4\u04E6\u04E8\u04EA\u04EC\u04EE\u04F0\u04F2\u04F4\u04F6\u04F8\u04FA\u04FC\u04FE\u0500\u0502\u0504\u0506\u0508\u050A\u050C\u050E\u0510\u0512\u0514\u0516\u0518\u051A\u051C\u051E\u0520\u0522\u0524\u0526\u0531-\u0556\u10A0-\u10C5\u10C7\u10CD\u1E00\u1E02\u1E04\u1E06\u1E08\u1E0A\u1E0C\u1E0E\u1E10\u1E12\u1E14\u1E16\u1E18\u1E1A\u1E1C\u1E1E\u1E20\u1E22\u1E24\u1E26\u1E28\u1E2A\u1E2C\u1E2E\u1E30\u1E32\u1E34\u1E36\u1E38\u1E3A\u1E3C\u1E3E\u1E40\u1E42\u1E44\u1E46\u1E48\u1E4A\u1E4C\u1E4E\u1E50\u1E52\u1E54\u1E56\u1E58\u1E5A\u1E5C\u1E5E\u1E60\u1E62\u1E64\u1E66\u1E68\u1E6A\u1E6C\u1E6E\u1E70\u1E72\u1E74\u1E76\u1E78\u1E7A\u1E7C\u1E7E\u1E80\u1E82\u1E84\u1E86\u1E88\u1E8A\u1E8C\u1E8E\u1E90\u1E92\u1E94\u1E9E\u1EA0\u1EA2\u1EA4\u1EA6\u1EA8\u1EAA\u1EAC\u1EAE\u1EB0\u1EB2\u1EB4\u1EB6\u1EB8\u1EBA\u1EBC\u1EBE\u1EC0\u1EC2\u1EC4\u1EC6\u1EC8\u1ECA\u1ECC\u1ECE\u1ED0\u1ED2\u1ED4\u1ED6\u1ED8\u1EDA\u1EDC\u1EDE\u1EE0\u1EE2\u1EE4\u1EE6\u1EE8\u1EEA\u1EEC\u1EEE\u1EF0\u1EF2\u1EF4\u1EF6\u1EF8\u1EFA\u1EFC\u1EFE\u1F08-\u1F0F\u1F18-\u1F1D\u1F28-\u1F2F\u1F38-\u1F3F\u1F48-\u1F4D\u1F59\u1F5B\u1F5D\u1F5F\u1F68-\u1F6F\u1FB8-\u1FBB\u1FC8-\u1FCB\u1FD8-\u1FDB\u1FE8-\u1FEC\u1FF8-\u1FFB\u2102\u2107\u210B-\u210D\u2110-\u2112\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u2130-\u2133\u213E\u213F\u2145\u2183\u2C00-\u2C2E\u2C60\u2C62-\u2C64\u2C67\u2C69\u2C6B\u2C6D-\u2C70\u2C72\u2C75\u2C7E-\u2C80\u2C82\u2C84\u2C86\u2C88\u2C8A\u2C8C\u2C8E\u2C90\u2C92\u2C94\u2C96\u2C98\u2C9A\u2C9C\u2C9E\u2CA0\u2CA2\u2CA4\u2CA6\u2CA8\u2CAA\u2CAC\u2CAE\u2CB0\u2CB2\u2CB4\u2CB6\u2CB8\u2CBA\u2CBC\u2CBE\u2CC0\u2CC2\u2CC4\u2CC6\u2CC8\u2CCA\u2CCC\u2CCE\u2CD0\u2CD2\u2CD4\u2CD6\u2CD8\u2CDA\u2CDC\u2CDE\u2CE0\u2CE2\u2CEB\u2CED\u2CF2\uA640\uA642\uA644\uA646\uA648\uA64A\uA64C\uA64E\uA650\uA652\uA654\uA656\uA658\uA65A\uA65C\uA65E\uA660\uA662\uA664\uA666\uA668\uA66A\uA66C\uA680\uA682\uA684\uA686\uA688\uA68A\uA68C\uA68E\uA690\uA692\uA694\uA696\uA722\uA724\uA726\uA728\uA72A\uA72C\uA72E\uA732\uA734\uA736\uA738\uA73A\uA73C\uA73E\uA740\uA742\uA744\uA746\uA748\uA74A\uA74C\uA74E\uA750\uA752\uA754\uA756\uA758\uA75A\uA75C\uA75E\uA760\uA762\uA764\uA766\uA768\uA76A\uA76C\uA76E\uA779\uA77B\uA77D\uA77E\uA780\uA782\uA784\uA786\uA78B\uA78D\uA790\uA792\uA7A0\uA7A2\uA7A4\uA7A6\uA7A8\uA7AA\uFF21-\uFF3A\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/non-word-regexp.js":[function(require,module,exports){
module.exports = /[^\u0041-\u005A\u0061-\u007A\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19]+/g

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/vendor/trailing-digit-regexp.js":[function(require,module,exports){
module.exports = /([\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])([^\u0030-\u0039\u00B2\u00B3\u00B9\u00BC-\u00BE\u0660-\u0669\u06F0-\u06F9\u07C0-\u07C9\u0966-\u096F\u09E6-\u09EF\u09F4-\u09F9\u0A66-\u0A6F\u0AE6-\u0AEF\u0B66-\u0B6F\u0B72-\u0B77\u0BE6-\u0BF2\u0C66-\u0C6F\u0C78-\u0C7E\u0CE6-\u0CEF\u0D66-\u0D75\u0E50-\u0E59\u0ED0-\u0ED9\u0F20-\u0F33\u1040-\u1049\u1090-\u1099\u1369-\u137C\u16EE-\u16F0\u17E0-\u17E9\u17F0-\u17F9\u1810-\u1819\u1946-\u194F\u19D0-\u19DA\u1A80-\u1A89\u1A90-\u1A99\u1B50-\u1B59\u1BB0-\u1BB9\u1C40-\u1C49\u1C50-\u1C59\u2070\u2074-\u2079\u2080-\u2089\u2150-\u2182\u2185-\u2189\u2460-\u249B\u24EA-\u24FF\u2776-\u2793\u2CFD\u3007\u3021-\u3029\u3038-\u303A\u3192-\u3195\u3220-\u3229\u3248-\u324F\u3251-\u325F\u3280-\u3289\u32B1-\u32BF\uA620-\uA629\uA6E6-\uA6EF\uA830-\uA835\uA8D0-\uA8D9\uA900-\uA909\uA9D0-\uA9D9\uAA50-\uAA59\uABF0-\uABF9\uFF10-\uFF19])/g

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/param-case.js":[function(require,module,exports){
var sentenceCase = require('sentence-case');

/**
 * Param case a string.
 *
 * @param  {String} string
 * @param  {String} [locale]
 * @return {String}
 */
module.exports = function (string, locale) {
  return sentenceCase(string, locale, '-');
};

},{"sentence-case":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/param-case/node_modules/sentence-case/sentence-case.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/attribute-hook.js":[function(require,module,exports){
'use strict';

module.exports = AttributeHook;

function AttributeHook(namespace, value) {
    if (!(this instanceof AttributeHook)) {
        return new AttributeHook(namespace, value);
    }

    this.namespace = namespace;
    this.value = value;
}

AttributeHook.prototype.hook = function (node, prop, prev) {
    if (prev && prev.type === 'AttributeHook' &&
        prev.value === this.value &&
        prev.namespace === this.namespace) {
        return;
    }

    node.setAttributeNS(this.namespace, prop, this.value);
};

AttributeHook.prototype.unhook = function (node, prop, next) {
    if (next && next.type === 'AttributeHook' &&
        next.namespace === this.namespace) {
        return;
    }

    var colonPosition = prop.indexOf(':');
    var localName = colonPosition > -1 ? prop.substr(colonPosition + 1) : prop;
    node.removeAttributeNS(this.namespace, localName);
};

AttributeHook.prototype.type = 'AttributeHook';

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js":[function(require,module,exports){
'use strict';

module.exports = SoftSetHook;

function SoftSetHook(value) {
    if (!(this instanceof SoftSetHook)) {
        return new SoftSetHook(value);
    }

    this.value = value;
}

SoftSetHook.prototype.hook = function (node, propertyName) {
    if (node[propertyName] !== this.value) {
        node[propertyName] = this.value;
    }
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-thunk.js":[function(require,module,exports){
module.exports = isThunk

function isThunk(t) {
    return t && t.type === "Thunk"
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vnode.js":[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualNode

function isVirtualNode(x) {
    return x && x.type === "VirtualNode" && x.version === version
}

},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vtext.js":[function(require,module,exports){
var version = require("./version")

module.exports = isVirtualText

function isVirtualText(x) {
    return x && x.type === "VirtualText" && x.version === version
}

},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/version.js":[function(require,module,exports){
module.exports = "2"

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/xtend/immutable.js":[function(require,module,exports){
module.exports = extend

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (source.hasOwnProperty(key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/property-config.js":[function(require,module,exports){
/**
 * Attribute types.
 */

var types = {
  BOOLEAN: 1,
  OVERLOADED_BOOLEAN: 2
};

/**
 * Properties.
 *
 * Taken from https://github.com/facebook/react/blob/847357e42e5267b04dd6e297219eaa125ab2f9f4/src/browser/ui/dom/HTMLDOMPropertyConfig.js
 *
 */

var properties = {
  /**
   * Standard Properties
   */
  accept: true,
  acceptCharset: true,
  accessKey: true,
  action: true,
  allowFullScreen: types.BOOLEAN,
  allowTransparency: true,
  alt: true,
  async: types.BOOLEAN,
  autocomplete: true,
  autofocus: types.BOOLEAN,
  autoplay: types.BOOLEAN,
  cellPadding: true,
  cellSpacing: true,
  charset: true,
  checked: types.BOOLEAN,
  classID: true,
  className: true,
  cols: true,
  colSpan: true,
  content: true,
  contentEditable: true,
  contextMenu: true,
  controls: types.BOOLEAN,
  coords: true,
  crossOrigin: true,
  data: true, // For `<object />` acts as `src`.
  dateTime: true,
  defer: types.BOOLEAN,
  dir: true,
  disabled: types.BOOLEAN,
  download: types.OVERLOADED_BOOLEAN,
  draggable: true,
  enctype: true,
  form: true,
  formAction: true,
  formEncType: true,
  formMethod: true,
  formNoValidate: types.BOOLEAN,
  formTarget: true,
  frameBorder: true,
  headers: true,
  height: true,
  hidden: types.BOOLEAN,
  href: true,
  hreflang: true,
  htmlFor: true,
  httpEquiv: true,
  icon: true,
  id: true,
  label: true,
  lang: true,
  list: true,
  loop: types.BOOLEAN,
  manifest: true,
  marginHeight: true,
  marginWidth: true,
  max: true,
  maxLength: true,
  media: true,
  mediaGroup: true,
  method: true,
  min: true,
  multiple: types.BOOLEAN,
  muted: types.BOOLEAN,
  name: true,
  noValidate: types.BOOLEAN,
  open: true,
  pattern: true,
  placeholder: true,
  poster: true,
  preload: true,
  radiogroup: true,
  readOnly: types.BOOLEAN,
  rel: true,
  required: types.BOOLEAN,
  role: true,
  rows: true,
  rowSpan: true,
  sandbox: true,
  scope: true,
  scrolling: true,
  seamless: types.BOOLEAN,
  selected: types.BOOLEAN,
  shape: true,
  size: true,
  sizes: true,
  span: true,
  spellcheck: true,
  src: true,
  srcdoc: true,
  srcset: true,
  start: true,
  step: true,
  style: true,
  tabIndex: true,
  target: true,
  title: true,
  type: true,
  useMap: true,
  value: true,
  width: true,
  wmode: true,

  /**
   * Non-standard Properties
   */
  // autoCapitalize and autoCorrect are supported in Mobile Safari for
  // keyboard hints.
  autocapitalize: true,
  autocorrect: true,
  // itemProp, itemScope, itemType are for Microdata support. See
  // http://schema.org/docs/gs.html
  itemProp: true,
  itemScope: types.BOOLEAN,
  itemType: true,
  // property is supported for OpenGraph in meta tags.
  property: true
};

/**
 * Properties to attributes mapping.
 *
 * The ones not here are simply converted to lower case.
 */

var attributeNames = {
  acceptCharset: 'accept-charset',
  className: 'class',
  htmlFor: 'for',
  httpEquiv: 'http-equiv'
};

/**
 * Exports.
 */

module.exports = {
  attributeTypes: types,
  properties: properties,
  attributeNames: attributeNames
};
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/void-elements.js":[function(require,module,exports){

/**
 * Void elements.
 *
 * https://github.com/facebook/react/blob/v0.12.0/src/browser/ui/ReactDOMComponent.js#L99
 */

module.exports = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/create-element.js":[function(require,module,exports){
var createElement = require("./vdom/create-element.js")

module.exports = createElement

},{"./vdom/create-element.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/create-element.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/diff.js":[function(require,module,exports){
var diff = require("./vtree/diff.js")

module.exports = diff

},{"./vtree/diff.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vtree/diff.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/h.js":[function(require,module,exports){
var h = require("./virtual-hyperscript/index.js")

module.exports = h

},{"./virtual-hyperscript/index.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/browser-split/index.js":[function(require,module,exports){
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
module.exports = (function split(undef) {

  var nativeSplit = String.prototype.split,
    compliantExecNpcg = /()??/.exec("")[1] === undef,
    // NPCG: nonparticipating capturing group
    self;

  self = function(str, separator, limit) {
    // If `separator` is not a regex, use `nativeSplit`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
      return nativeSplit.call(str, separator, limit);
    }
    var output = [],
      flags = (separator.ignoreCase ? "i" : "") + (separator.multiline ? "m" : "") + (separator.extended ? "x" : "") + // Proposed for ES6
      (separator.sticky ? "y" : ""),
      // Firefox 3+
      lastLastIndex = 0,
      // Make `global` and avoid `lastIndex` issues by working with a copy
      separator = new RegExp(separator.source, flags + "g"),
      separator2, match, lastIndex, lastLength;
    str += ""; // Type-convert
    if (!compliantExecNpcg) {
      // Doesn't need flags gy, but they don't hurt
      separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
    }
    /* Values for `limit`, per the spec:
     * If undefined: 4294967295 // Math.pow(2, 32) - 1
     * If 0, Infinity, or NaN: 0
     * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
     * If negative number: 4294967296 - Math.floor(Math.abs(limit))
     * If other: Type-convert, then use the above rules
     */
    limit = limit === undef ? -1 >>> 0 : // Math.pow(2, 32) - 1
    limit >>> 0; // ToUint32(limit)
    while (match = separator.exec(str)) {
      // `separator.lastIndex` is not reliable cross-browser
      lastIndex = match.index + match[0].length;
      if (lastIndex > lastLastIndex) {
        output.push(str.slice(lastLastIndex, match.index));
        // Fix browsers whose `exec` methods don't consistently return `undefined` for
        // nonparticipating capturing groups
        if (!compliantExecNpcg && match.length > 1) {
          match[0].replace(separator2, function() {
            for (var i = 1; i < arguments.length - 2; i++) {
              if (arguments[i] === undef) {
                match[i] = undef;
              }
            }
          });
        }
        if (match.length > 1 && match.index < str.length) {
          Array.prototype.push.apply(output, match.slice(1));
        }
        lastLength = match[0].length;
        lastLastIndex = lastIndex;
        if (output.length >= limit) {
          break;
        }
      }
      if (separator.lastIndex === match.index) {
        separator.lastIndex++; // Avoid an infinite loop
      }
    }
    if (lastLastIndex === str.length) {
      if (lastLength || !separator.test("")) {
        output.push("");
      }
    } else {
      output.push(str.slice(lastLastIndex));
    }
    return output.length > limit ? output.slice(0, limit) : output;
  };

  return self;
})();

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/index.js":[function(require,module,exports){
'use strict';

var OneVersionConstraint = require('individual/one-version');

var MY_VERSION = '7';
OneVersionConstraint('ev-store', MY_VERSION);

var hashKey = '__EV_STORE_KEY@' + MY_VERSION;

module.exports = EvStore;

function EvStore(elem) {
    var hash = elem[hashKey];

    if (!hash) {
        hash = elem[hashKey] = {};
    }

    return hash;
}

},{"individual/one-version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js":[function(require,module,exports){
(function (global){
'use strict';

/*global window, global*/

var root = typeof window !== 'undefined' ?
    window : typeof global !== 'undefined' ?
    global : {};

module.exports = Individual;

function Individual(key, value) {
    if (key in root) {
        return root[key];
    }

    root[key] = value;

    return value;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/one-version.js":[function(require,module,exports){
'use strict';

var Individual = require('./index.js');

module.exports = OneVersion;

function OneVersion(moduleName, version, defaultValue) {
    var key = '__INDIVIDUAL_ONE_VERSION_' + moduleName;
    var enforceKey = key + '_ENFORCE_SINGLETON';

    var versionValue = Individual(enforceKey, version);

    if (versionValue !== version) {
        throw new Error('Can only have one copy of ' +
            moduleName + '.\n' +
            'You already have version ' + versionValue +
            ' installed.\n' +
            'This means you cannot install version ' + version);
    }

    return Individual(key, defaultValue);
}

},{"./index.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/node_modules/individual/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/global/document.js":[function(require,module,exports){
(function (global){
var topLevel = typeof global !== 'undefined' ? global :
    typeof window !== 'undefined' ? window : {}
var minDoc = require('min-document');

if (typeof document !== 'undefined') {
    module.exports = document;
} else {
    var doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'];

    if (!doccy) {
        doccy = topLevel['__GLOBAL_DOCUMENT_CACHE@4'] = minDoc;
    }

    module.exports = doccy;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"min-document":"/Users/tcoats/Mayhem/wedding/node_modules/browserify/node_modules/browser-resolve/empty.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/is-object/index.js":[function(require,module,exports){
"use strict";

module.exports = function isObject(x) {
	return typeof x === "object" && x !== null;
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/x-is-array/index.js":[function(require,module,exports){
var nativeIsArray = Array.isArray
var toString = Object.prototype.toString

module.exports = nativeIsArray || isArray

function isArray(obj) {
    return toString.call(obj) === "[object Array]"
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/patch.js":[function(require,module,exports){
var patch = require("./vdom/patch.js")

module.exports = patch

},{"./vdom/patch.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/patch.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/apply-properties.js":[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook.js")

module.exports = applyProperties

function applyProperties(node, props, previous) {
    for (var propName in props) {
        var propValue = props[propName]

        if (propValue === undefined) {
            removeProperty(node, propName, propValue, previous);
        } else if (isHook(propValue)) {
            removeProperty(node, propName, propValue, previous)
            if (propValue.hook) {
                propValue.hook(node,
                    propName,
                    previous ? previous[propName] : undefined)
            }
        } else {
            if (isObject(propValue)) {
                patchObject(node, props, previous, propName, propValue);
            } else {
                node[propName] = propValue
            }
        }
    }
}

function removeProperty(node, propName, propValue, previous) {
    if (previous) {
        var previousValue = previous[propName]

        if (!isHook(previousValue)) {
            if (propName === "attributes") {
                for (var attrName in previousValue) {
                    node.removeAttribute(attrName)
                }
            } else if (propName === "style") {
                for (var i in previousValue) {
                    node.style[i] = ""
                }
            } else if (typeof previousValue === "string") {
                node[propName] = ""
            } else {
                node[propName] = null
            }
        } else if (previousValue.unhook) {
            previousValue.unhook(node, propName, propValue)
        }
    }
}

function patchObject(node, props, previous, propName, propValue) {
    var previousValue = previous ? previous[propName] : undefined

    // Set attributes
    if (propName === "attributes") {
        for (var attrName in propValue) {
            var attrValue = propValue[attrName]

            if (attrValue === undefined) {
                node.removeAttribute(attrName)
            } else {
                node.setAttribute(attrName, attrValue)
            }
        }

        return
    }

    if(previousValue && isObject(previousValue) &&
        getPrototype(previousValue) !== getPrototype(propValue)) {
        node[propName] = propValue
        return
    }

    if (!isObject(node[propName])) {
        node[propName] = {}
    }

    var replacer = propName === "style" ? "" : undefined

    for (var k in propValue) {
        var value = propValue[k]
        node[propName][k] = (value === undefined) ? replacer : value
    }
}

function getPrototype(value) {
    if (Object.getPrototypeOf) {
        return Object.getPrototypeOf(value)
    } else if (value.__proto__) {
        return value.__proto__
    } else if (value.constructor) {
        return value.constructor.prototype
    }
}

},{"../vnode/is-vhook.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vhook.js","is-object":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/is-object/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/create-element.js":[function(require,module,exports){
var document = require("global/document")

var applyProperties = require("./apply-properties")

var isVNode = require("../vnode/is-vnode.js")
var isVText = require("../vnode/is-vtext.js")
var isWidget = require("../vnode/is-widget.js")
var handleThunk = require("../vnode/handle-thunk.js")

module.exports = createElement

function createElement(vnode, opts) {
    var doc = opts ? opts.document || document : document
    var warn = opts ? opts.warn : null

    vnode = handleThunk(vnode).a

    if (isWidget(vnode)) {
        return vnode.init()
    } else if (isVText(vnode)) {
        return doc.createTextNode(vnode.text)
    } else if (!isVNode(vnode)) {
        if (warn) {
            warn("Item is not a valid virtual dom node", vnode)
        }
        return null
    }

    var node = (vnode.namespace === null) ?
        doc.createElement(vnode.tagName) :
        doc.createElementNS(vnode.namespace, vnode.tagName)

    var props = vnode.properties
    applyProperties(node, props)

    var children = vnode.children

    for (var i = 0; i < children.length; i++) {
        var childNode = createElement(children[i], opts)
        if (childNode) {
            node.appendChild(childNode)
        }
    }

    return node
}

},{"../vnode/handle-thunk.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/handle-thunk.js","../vnode/is-vnode.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js","./apply-properties":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/apply-properties.js","global/document":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/global/document.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/dom-index.js":[function(require,module,exports){
// Maps a virtual DOM tree onto a real DOM tree in an efficient manner.
// We don't want to read all of the DOM nodes in the tree so we use
// the in-order tree indexing to eliminate recursion down certain branches.
// We only recurse into a DOM node if we know that it contains a child of
// interest.

var noChild = {}

module.exports = domIndex

function domIndex(rootNode, tree, indices, nodes) {
    if (!indices || indices.length === 0) {
        return {}
    } else {
        indices.sort(ascending)
        return recurse(rootNode, tree, indices, nodes, 0)
    }
}

function recurse(rootNode, tree, indices, nodes, rootIndex) {
    nodes = nodes || {}


    if (rootNode) {
        if (indexInRange(indices, rootIndex, rootIndex)) {
            nodes[rootIndex] = rootNode
        }

        var vChildren = tree.children

        if (vChildren) {

            var childNodes = rootNode.childNodes

            for (var i = 0; i < tree.children.length; i++) {
                rootIndex += 1

                var vChild = vChildren[i] || noChild
                var nextIndex = rootIndex + (vChild.count || 0)

                // skip recursion down the tree if there are no nodes down here
                if (indexInRange(indices, rootIndex, nextIndex)) {
                    recurse(childNodes[i], vChild, indices, nodes, rootIndex)
                }

                rootIndex = nextIndex
            }
        }
    }

    return nodes
}

// Binary search for an index in the interval [left, right]
function indexInRange(indices, left, right) {
    if (indices.length === 0) {
        return false
    }

    var minIndex = 0
    var maxIndex = indices.length - 1
    var currentIndex
    var currentItem

    while (minIndex <= maxIndex) {
        currentIndex = ((maxIndex + minIndex) / 2) >> 0
        currentItem = indices[currentIndex]

        if (minIndex === maxIndex) {
            return currentItem >= left && currentItem <= right
        } else if (currentItem < left) {
            minIndex = currentIndex + 1
        } else  if (currentItem > right) {
            maxIndex = currentIndex - 1
        } else {
            return true
        }
    }

    return false;
}

function ascending(a, b) {
    return a > b ? 1 : -1
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/patch-op.js":[function(require,module,exports){
var applyProperties = require("./apply-properties")

var isWidget = require("../vnode/is-widget.js")
var VPatch = require("../vnode/vpatch.js")

var render = require("./create-element")
var updateWidget = require("./update-widget")

module.exports = applyPatch

function applyPatch(vpatch, domNode, renderOptions) {
    var type = vpatch.type
    var vNode = vpatch.vNode
    var patch = vpatch.patch

    switch (type) {
        case VPatch.REMOVE:
            return removeNode(domNode, vNode)
        case VPatch.INSERT:
            return insertNode(domNode, patch, renderOptions)
        case VPatch.VTEXT:
            return stringPatch(domNode, vNode, patch, renderOptions)
        case VPatch.WIDGET:
            return widgetPatch(domNode, vNode, patch, renderOptions)
        case VPatch.VNODE:
            return vNodePatch(domNode, vNode, patch, renderOptions)
        case VPatch.ORDER:
            reorderChildren(domNode, patch)
            return domNode
        case VPatch.PROPS:
            applyProperties(domNode, patch, vNode.properties)
            return domNode
        case VPatch.THUNK:
            return replaceRoot(domNode,
                renderOptions.patch(domNode, patch, renderOptions))
        default:
            return domNode
    }
}

function removeNode(domNode, vNode) {
    var parentNode = domNode.parentNode

    if (parentNode) {
        parentNode.removeChild(domNode)
    }

    destroyWidget(domNode, vNode);

    return null
}

function insertNode(parentNode, vNode, renderOptions) {
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.appendChild(newNode)
    }

    return parentNode
}

function stringPatch(domNode, leftVNode, vText, renderOptions) {
    var newNode

    if (domNode.nodeType === 3) {
        domNode.replaceData(0, domNode.length, vText.text)
        newNode = domNode
    } else {
        var parentNode = domNode.parentNode
        newNode = render(vText, renderOptions)

        if (parentNode) {
            parentNode.replaceChild(newNode, domNode)
        }
    }

    return newNode
}

function widgetPatch(domNode, leftVNode, widget, renderOptions) {
    var updating = updateWidget(leftVNode, widget)
    var newNode

    if (updating) {
        newNode = widget.update(leftVNode, domNode) || domNode
    } else {
        newNode = render(widget, renderOptions)
    }

    var parentNode = domNode.parentNode

    if (parentNode && newNode !== domNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    if (!updating) {
        destroyWidget(domNode, leftVNode)
    }

    return newNode
}

function vNodePatch(domNode, leftVNode, vNode, renderOptions) {
    var parentNode = domNode.parentNode
    var newNode = render(vNode, renderOptions)

    if (parentNode) {
        parentNode.replaceChild(newNode, domNode)
    }

    return newNode
}

function destroyWidget(domNode, w) {
    if (typeof w.destroy === "function" && isWidget(w)) {
        w.destroy(domNode)
    }
}

function reorderChildren(domNode, bIndex) {
    var children = []
    var childNodes = domNode.childNodes
    var len = childNodes.length
    var i
    var reverseIndex = bIndex.reverse

    for (i = 0; i < len; i++) {
        children.push(domNode.childNodes[i])
    }

    var insertOffset = 0
    var move
    var node
    var insertNode
    var chainLength
    var insertedLength
    var nextSibling
    for (i = 0; i < len;) {
        move = bIndex[i]
        chainLength = 1
        if (move !== undefined && move !== i) {
            // try to bring forward as long of a chain as possible
            while (bIndex[i + chainLength] === move + chainLength) {
                chainLength++;
            }

            // the element currently at this index will be moved later so increase the insert offset
            if (reverseIndex[i] > i + chainLength) {
                insertOffset++
            }

            node = children[move]
            insertNode = childNodes[i + insertOffset] || null
            insertedLength = 0
            while (node !== insertNode && insertedLength++ < chainLength) {
                domNode.insertBefore(node, insertNode);
                node = children[move + insertedLength];
            }

            // the moved element came from the front of the array so reduce the insert offset
            if (move + chainLength < i) {
                insertOffset--
            }
        }

        // element at this index is scheduled to be removed so increase insert offset
        if (i in bIndex.removes) {
            insertOffset++
        }

        i += chainLength
    }
}

function replaceRoot(oldRoot, newRoot) {
    if (oldRoot && newRoot && oldRoot !== newRoot && oldRoot.parentNode) {
        console.log(oldRoot)
        oldRoot.parentNode.replaceChild(newRoot, oldRoot)
    }

    return newRoot;
}

},{"../vnode/is-widget.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vpatch.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vpatch.js","./apply-properties":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/apply-properties.js","./create-element":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/create-element.js","./update-widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/update-widget.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/patch.js":[function(require,module,exports){
var document = require("global/document")
var isArray = require("x-is-array")

var domIndex = require("./dom-index")
var patchOp = require("./patch-op")
module.exports = patch

function patch(rootNode, patches) {
    return patchRecursive(rootNode, patches)
}

function patchRecursive(rootNode, patches, renderOptions) {
    var indices = patchIndices(patches)

    if (indices.length === 0) {
        return rootNode
    }

    var index = domIndex(rootNode, patches.a, indices)
    var ownerDocument = rootNode.ownerDocument

    if (!renderOptions) {
        renderOptions = { patch: patchRecursive }
        if (ownerDocument !== document) {
            renderOptions.document = ownerDocument
        }
    }

    for (var i = 0; i < indices.length; i++) {
        var nodeIndex = indices[i]
        rootNode = applyPatch(rootNode,
            index[nodeIndex],
            patches[nodeIndex],
            renderOptions)
    }

    return rootNode
}

function applyPatch(rootNode, domNode, patchList, renderOptions) {
    if (!domNode) {
        return rootNode
    }

    var newNode

    if (isArray(patchList)) {
        for (var i = 0; i < patchList.length; i++) {
            newNode = patchOp(patchList[i], domNode, renderOptions)

            if (domNode === rootNode) {
                rootNode = newNode
            }
        }
    } else {
        newNode = patchOp(patchList, domNode, renderOptions)

        if (domNode === rootNode) {
            rootNode = newNode
        }
    }

    return rootNode
}

function patchIndices(patches) {
    var indices = []

    for (var key in patches) {
        if (key !== "a") {
            indices.push(Number(key))
        }
    }

    return indices
}

},{"./dom-index":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/dom-index.js","./patch-op":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/patch-op.js","global/document":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/global/document.js","x-is-array":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vdom/update-widget.js":[function(require,module,exports){
var isWidget = require("../vnode/is-widget.js")

module.exports = updateWidget

function updateWidget(a, b) {
    if (isWidget(a) && isWidget(b)) {
        if ("name" in a && "name" in b) {
            return a.id === b.id
        } else {
            return a.init === b.init
        }
    }

    return false
}

},{"../vnode/is-widget.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/attribute-hook.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/attribute-hook.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js":[function(require,module,exports){
'use strict';

var EvStore = require('ev-store');

module.exports = EvHook;

function EvHook(value) {
    if (!(this instanceof EvHook)) {
        return new EvHook(value);
    }

    this.value = value;
}

EvHook.prototype.hook = function (node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = this.value;
};

EvHook.prototype.unhook = function(node, propertyName) {
    var es = EvStore(node);
    var propName = propertyName.substr(3);

    es[propName] = undefined;
};

},{"ev-store":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/ev-store/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/index.js":[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var VNode = require('../vnode/vnode.js');
var VText = require('../vnode/vtext.js');
var isVNode = require('../vnode/is-vnode');
var isVText = require('../vnode/is-vtext');
var isWidget = require('../vnode/is-widget');
var isHook = require('../vnode/is-vhook');
var isVThunk = require('../vnode/is-thunk');

var parseTag = require('./parse-tag.js');
var softSetHook = require('./hooks/soft-set-hook.js');
var evHook = require('./hooks/ev-hook.js');

module.exports = h;

function h(tagName, properties, children) {
    var childNodes = [];
    var tag, props, key, namespace;

    if (!children && isChildren(properties)) {
        children = properties;
        props = {};
    }

    props = props || properties || {};
    tag = parseTag(tagName, props);

    // support keys
    if (props.hasOwnProperty('key')) {
        key = props.key;
        props.key = undefined;
    }

    // support namespace
    if (props.hasOwnProperty('namespace')) {
        namespace = props.namespace;
        props.namespace = undefined;
    }

    // fix cursor bug
    if (tag === 'INPUT' &&
        !namespace &&
        props.hasOwnProperty('value') &&
        props.value !== undefined &&
        !isHook(props.value)
    ) {
        props.value = softSetHook(props.value);
    }

    transformProperties(props);

    if (children !== undefined && children !== null) {
        addChild(children, childNodes, tag, props);
    }


    return new VNode(tag, props, childNodes, key, namespace);
}

function addChild(c, childNodes, tag, props) {
    if (typeof c === 'string') {
        childNodes.push(new VText(c));
    } else if (isChild(c)) {
        childNodes.push(c);
    } else if (isArray(c)) {
        for (var i = 0; i < c.length; i++) {
            addChild(c[i], childNodes, tag, props);
        }
    } else if (c === null || c === undefined) {
        return;
    } else {
        throw UnexpectedVirtualElement({
            foreignObject: c,
            parentVnode: {
                tagName: tag,
                properties: props
            }
        });
    }
}

function transformProperties(props) {
    for (var propName in props) {
        if (props.hasOwnProperty(propName)) {
            var value = props[propName];

            if (isHook(value)) {
                continue;
            }

            if (propName.substr(0, 3) === 'ev-') {
                // add ev-foo support
                props[propName] = evHook(value);
            }
        }
    }
}

function isChild(x) {
    return isVNode(x) || isVText(x) || isWidget(x) || isVThunk(x);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x) || isChild(x);
}

function UnexpectedVirtualElement(data) {
    var err = new Error();

    err.type = 'virtual-hyperscript.unexpected.virtual-element';
    err.message = 'Unexpected virtual child passed to h().\n' +
        'Expected a VNode / Vthunk / VWidget / string but:\n' +
        'got:\n' +
        errorString(data.foreignObject) +
        '.\n' +
        'The parent vnode is:\n' +
        errorString(data.parentVnode)
        '\n' +
        'Suggested fix: change your `h(..., [ ... ])` callsite.';
    err.foreignObject = data.foreignObject;
    err.parentVnode = data.parentVnode;

    return err;
}

function errorString(obj) {
    try {
        return JSON.stringify(obj, null, '    ');
    } catch (e) {
        return String(obj);
    }
}

},{"../vnode/is-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-thunk.js","../vnode/is-vhook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vhook.js","../vnode/is-vnode":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vnode.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vnode.js","../vnode/vtext.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vtext.js","./hooks/ev-hook.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/ev-hook.js","./hooks/soft-set-hook.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/soft-set-hook.js","./parse-tag.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js","x-is-array":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/parse-tag.js":[function(require,module,exports){
'use strict';

var split = require('browser-split');

var classIdSplit = /([\.#]?[a-zA-Z0-9_:-]+)/;
var notClassId = /^\.|#/;

module.exports = parseTag;

function parseTag(tag, props) {
    if (!tag) {
        return 'DIV';
    }

    var noId = !(props.hasOwnProperty('id'));

    var tagParts = split(tag, classIdSplit);
    var tagName = null;

    if (notClassId.test(tagParts[1])) {
        tagName = 'DIV';
    }

    var classes, part, type, i;

    for (i = 0; i < tagParts.length; i++) {
        part = tagParts[i];

        if (!part) {
            continue;
        }

        type = part.charAt(0);

        if (!tagName) {
            tagName = part;
        } else if (type === '.') {
            classes = classes || [];
            classes.push(part.substring(1, part.length));
        } else if (type === '#' && noId) {
            props.id = part.substring(1, part.length);
        }
    }

    if (classes) {
        if (props.className) {
            classes.push(props.className);
        }

        props.className = classes.join(' ');
    }

    return props.namespace ? tagName : tagName.toUpperCase();
}

},{"browser-split":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/browser-split/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/svg-attribute-namespace.js":[function(require,module,exports){
'use strict';

var DEFAULT_NAMESPACE = null;
var EV_NAMESPACE = 'http://www.w3.org/2001/xml-events';
var XLINK_NAMESPACE = 'http://www.w3.org/1999/xlink';
var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace';

// http://www.w3.org/TR/SVGTiny12/attributeTable.html
// http://www.w3.org/TR/SVG/attindex.html
var SVG_PROPERTIES = {
    'about': DEFAULT_NAMESPACE,
    'accent-height': DEFAULT_NAMESPACE,
    'accumulate': DEFAULT_NAMESPACE,
    'additive': DEFAULT_NAMESPACE,
    'alignment-baseline': DEFAULT_NAMESPACE,
    'alphabetic': DEFAULT_NAMESPACE,
    'amplitude': DEFAULT_NAMESPACE,
    'arabic-form': DEFAULT_NAMESPACE,
    'ascent': DEFAULT_NAMESPACE,
    'attributeName': DEFAULT_NAMESPACE,
    'attributeType': DEFAULT_NAMESPACE,
    'azimuth': DEFAULT_NAMESPACE,
    'bandwidth': DEFAULT_NAMESPACE,
    'baseFrequency': DEFAULT_NAMESPACE,
    'baseProfile': DEFAULT_NAMESPACE,
    'baseline-shift': DEFAULT_NAMESPACE,
    'bbox': DEFAULT_NAMESPACE,
    'begin': DEFAULT_NAMESPACE,
    'bias': DEFAULT_NAMESPACE,
    'by': DEFAULT_NAMESPACE,
    'calcMode': DEFAULT_NAMESPACE,
    'cap-height': DEFAULT_NAMESPACE,
    'class': DEFAULT_NAMESPACE,
    'clip': DEFAULT_NAMESPACE,
    'clip-path': DEFAULT_NAMESPACE,
    'clip-rule': DEFAULT_NAMESPACE,
    'clipPathUnits': DEFAULT_NAMESPACE,
    'color': DEFAULT_NAMESPACE,
    'color-interpolation': DEFAULT_NAMESPACE,
    'color-interpolation-filters': DEFAULT_NAMESPACE,
    'color-profile': DEFAULT_NAMESPACE,
    'color-rendering': DEFAULT_NAMESPACE,
    'content': DEFAULT_NAMESPACE,
    'contentScriptType': DEFAULT_NAMESPACE,
    'contentStyleType': DEFAULT_NAMESPACE,
    'cursor': DEFAULT_NAMESPACE,
    'cx': DEFAULT_NAMESPACE,
    'cy': DEFAULT_NAMESPACE,
    'd': DEFAULT_NAMESPACE,
    'datatype': DEFAULT_NAMESPACE,
    'defaultAction': DEFAULT_NAMESPACE,
    'descent': DEFAULT_NAMESPACE,
    'diffuseConstant': DEFAULT_NAMESPACE,
    'direction': DEFAULT_NAMESPACE,
    'display': DEFAULT_NAMESPACE,
    'divisor': DEFAULT_NAMESPACE,
    'dominant-baseline': DEFAULT_NAMESPACE,
    'dur': DEFAULT_NAMESPACE,
    'dx': DEFAULT_NAMESPACE,
    'dy': DEFAULT_NAMESPACE,
    'edgeMode': DEFAULT_NAMESPACE,
    'editable': DEFAULT_NAMESPACE,
    'elevation': DEFAULT_NAMESPACE,
    'enable-background': DEFAULT_NAMESPACE,
    'end': DEFAULT_NAMESPACE,
    'ev:event': EV_NAMESPACE,
    'event': DEFAULT_NAMESPACE,
    'exponent': DEFAULT_NAMESPACE,
    'externalResourcesRequired': DEFAULT_NAMESPACE,
    'fill': DEFAULT_NAMESPACE,
    'fill-opacity': DEFAULT_NAMESPACE,
    'fill-rule': DEFAULT_NAMESPACE,
    'filter': DEFAULT_NAMESPACE,
    'filterRes': DEFAULT_NAMESPACE,
    'filterUnits': DEFAULT_NAMESPACE,
    'flood-color': DEFAULT_NAMESPACE,
    'flood-opacity': DEFAULT_NAMESPACE,
    'focusHighlight': DEFAULT_NAMESPACE,
    'focusable': DEFAULT_NAMESPACE,
    'font-family': DEFAULT_NAMESPACE,
    'font-size': DEFAULT_NAMESPACE,
    'font-size-adjust': DEFAULT_NAMESPACE,
    'font-stretch': DEFAULT_NAMESPACE,
    'font-style': DEFAULT_NAMESPACE,
    'font-variant': DEFAULT_NAMESPACE,
    'font-weight': DEFAULT_NAMESPACE,
    'format': DEFAULT_NAMESPACE,
    'from': DEFAULT_NAMESPACE,
    'fx': DEFAULT_NAMESPACE,
    'fy': DEFAULT_NAMESPACE,
    'g1': DEFAULT_NAMESPACE,
    'g2': DEFAULT_NAMESPACE,
    'glyph-name': DEFAULT_NAMESPACE,
    'glyph-orientation-horizontal': DEFAULT_NAMESPACE,
    'glyph-orientation-vertical': DEFAULT_NAMESPACE,
    'glyphRef': DEFAULT_NAMESPACE,
    'gradientTransform': DEFAULT_NAMESPACE,
    'gradientUnits': DEFAULT_NAMESPACE,
    'handler': DEFAULT_NAMESPACE,
    'hanging': DEFAULT_NAMESPACE,
    'height': DEFAULT_NAMESPACE,
    'horiz-adv-x': DEFAULT_NAMESPACE,
    'horiz-origin-x': DEFAULT_NAMESPACE,
    'horiz-origin-y': DEFAULT_NAMESPACE,
    'id': DEFAULT_NAMESPACE,
    'ideographic': DEFAULT_NAMESPACE,
    'image-rendering': DEFAULT_NAMESPACE,
    'in': DEFAULT_NAMESPACE,
    'in2': DEFAULT_NAMESPACE,
    'initialVisibility': DEFAULT_NAMESPACE,
    'intercept': DEFAULT_NAMESPACE,
    'k': DEFAULT_NAMESPACE,
    'k1': DEFAULT_NAMESPACE,
    'k2': DEFAULT_NAMESPACE,
    'k3': DEFAULT_NAMESPACE,
    'k4': DEFAULT_NAMESPACE,
    'kernelMatrix': DEFAULT_NAMESPACE,
    'kernelUnitLength': DEFAULT_NAMESPACE,
    'kerning': DEFAULT_NAMESPACE,
    'keyPoints': DEFAULT_NAMESPACE,
    'keySplines': DEFAULT_NAMESPACE,
    'keyTimes': DEFAULT_NAMESPACE,
    'lang': DEFAULT_NAMESPACE,
    'lengthAdjust': DEFAULT_NAMESPACE,
    'letter-spacing': DEFAULT_NAMESPACE,
    'lighting-color': DEFAULT_NAMESPACE,
    'limitingConeAngle': DEFAULT_NAMESPACE,
    'local': DEFAULT_NAMESPACE,
    'marker-end': DEFAULT_NAMESPACE,
    'marker-mid': DEFAULT_NAMESPACE,
    'marker-start': DEFAULT_NAMESPACE,
    'markerHeight': DEFAULT_NAMESPACE,
    'markerUnits': DEFAULT_NAMESPACE,
    'markerWidth': DEFAULT_NAMESPACE,
    'mask': DEFAULT_NAMESPACE,
    'maskContentUnits': DEFAULT_NAMESPACE,
    'maskUnits': DEFAULT_NAMESPACE,
    'mathematical': DEFAULT_NAMESPACE,
    'max': DEFAULT_NAMESPACE,
    'media': DEFAULT_NAMESPACE,
    'mediaCharacterEncoding': DEFAULT_NAMESPACE,
    'mediaContentEncodings': DEFAULT_NAMESPACE,
    'mediaSize': DEFAULT_NAMESPACE,
    'mediaTime': DEFAULT_NAMESPACE,
    'method': DEFAULT_NAMESPACE,
    'min': DEFAULT_NAMESPACE,
    'mode': DEFAULT_NAMESPACE,
    'name': DEFAULT_NAMESPACE,
    'nav-down': DEFAULT_NAMESPACE,
    'nav-down-left': DEFAULT_NAMESPACE,
    'nav-down-right': DEFAULT_NAMESPACE,
    'nav-left': DEFAULT_NAMESPACE,
    'nav-next': DEFAULT_NAMESPACE,
    'nav-prev': DEFAULT_NAMESPACE,
    'nav-right': DEFAULT_NAMESPACE,
    'nav-up': DEFAULT_NAMESPACE,
    'nav-up-left': DEFAULT_NAMESPACE,
    'nav-up-right': DEFAULT_NAMESPACE,
    'numOctaves': DEFAULT_NAMESPACE,
    'observer': DEFAULT_NAMESPACE,
    'offset': DEFAULT_NAMESPACE,
    'opacity': DEFAULT_NAMESPACE,
    'operator': DEFAULT_NAMESPACE,
    'order': DEFAULT_NAMESPACE,
    'orient': DEFAULT_NAMESPACE,
    'orientation': DEFAULT_NAMESPACE,
    'origin': DEFAULT_NAMESPACE,
    'overflow': DEFAULT_NAMESPACE,
    'overlay': DEFAULT_NAMESPACE,
    'overline-position': DEFAULT_NAMESPACE,
    'overline-thickness': DEFAULT_NAMESPACE,
    'panose-1': DEFAULT_NAMESPACE,
    'path': DEFAULT_NAMESPACE,
    'pathLength': DEFAULT_NAMESPACE,
    'patternContentUnits': DEFAULT_NAMESPACE,
    'patternTransform': DEFAULT_NAMESPACE,
    'patternUnits': DEFAULT_NAMESPACE,
    'phase': DEFAULT_NAMESPACE,
    'playbackOrder': DEFAULT_NAMESPACE,
    'pointer-events': DEFAULT_NAMESPACE,
    'points': DEFAULT_NAMESPACE,
    'pointsAtX': DEFAULT_NAMESPACE,
    'pointsAtY': DEFAULT_NAMESPACE,
    'pointsAtZ': DEFAULT_NAMESPACE,
    'preserveAlpha': DEFAULT_NAMESPACE,
    'preserveAspectRatio': DEFAULT_NAMESPACE,
    'primitiveUnits': DEFAULT_NAMESPACE,
    'propagate': DEFAULT_NAMESPACE,
    'property': DEFAULT_NAMESPACE,
    'r': DEFAULT_NAMESPACE,
    'radius': DEFAULT_NAMESPACE,
    'refX': DEFAULT_NAMESPACE,
    'refY': DEFAULT_NAMESPACE,
    'rel': DEFAULT_NAMESPACE,
    'rendering-intent': DEFAULT_NAMESPACE,
    'repeatCount': DEFAULT_NAMESPACE,
    'repeatDur': DEFAULT_NAMESPACE,
    'requiredExtensions': DEFAULT_NAMESPACE,
    'requiredFeatures': DEFAULT_NAMESPACE,
    'requiredFonts': DEFAULT_NAMESPACE,
    'requiredFormats': DEFAULT_NAMESPACE,
    'resource': DEFAULT_NAMESPACE,
    'restart': DEFAULT_NAMESPACE,
    'result': DEFAULT_NAMESPACE,
    'rev': DEFAULT_NAMESPACE,
    'role': DEFAULT_NAMESPACE,
    'rotate': DEFAULT_NAMESPACE,
    'rx': DEFAULT_NAMESPACE,
    'ry': DEFAULT_NAMESPACE,
    'scale': DEFAULT_NAMESPACE,
    'seed': DEFAULT_NAMESPACE,
    'shape-rendering': DEFAULT_NAMESPACE,
    'slope': DEFAULT_NAMESPACE,
    'snapshotTime': DEFAULT_NAMESPACE,
    'spacing': DEFAULT_NAMESPACE,
    'specularConstant': DEFAULT_NAMESPACE,
    'specularExponent': DEFAULT_NAMESPACE,
    'spreadMethod': DEFAULT_NAMESPACE,
    'startOffset': DEFAULT_NAMESPACE,
    'stdDeviation': DEFAULT_NAMESPACE,
    'stemh': DEFAULT_NAMESPACE,
    'stemv': DEFAULT_NAMESPACE,
    'stitchTiles': DEFAULT_NAMESPACE,
    'stop-color': DEFAULT_NAMESPACE,
    'stop-opacity': DEFAULT_NAMESPACE,
    'strikethrough-position': DEFAULT_NAMESPACE,
    'strikethrough-thickness': DEFAULT_NAMESPACE,
    'string': DEFAULT_NAMESPACE,
    'stroke': DEFAULT_NAMESPACE,
    'stroke-dasharray': DEFAULT_NAMESPACE,
    'stroke-dashoffset': DEFAULT_NAMESPACE,
    'stroke-linecap': DEFAULT_NAMESPACE,
    'stroke-linejoin': DEFAULT_NAMESPACE,
    'stroke-miterlimit': DEFAULT_NAMESPACE,
    'stroke-opacity': DEFAULT_NAMESPACE,
    'stroke-width': DEFAULT_NAMESPACE,
    'surfaceScale': DEFAULT_NAMESPACE,
    'syncBehavior': DEFAULT_NAMESPACE,
    'syncBehaviorDefault': DEFAULT_NAMESPACE,
    'syncMaster': DEFAULT_NAMESPACE,
    'syncTolerance': DEFAULT_NAMESPACE,
    'syncToleranceDefault': DEFAULT_NAMESPACE,
    'systemLanguage': DEFAULT_NAMESPACE,
    'tableValues': DEFAULT_NAMESPACE,
    'target': DEFAULT_NAMESPACE,
    'targetX': DEFAULT_NAMESPACE,
    'targetY': DEFAULT_NAMESPACE,
    'text-anchor': DEFAULT_NAMESPACE,
    'text-decoration': DEFAULT_NAMESPACE,
    'text-rendering': DEFAULT_NAMESPACE,
    'textLength': DEFAULT_NAMESPACE,
    'timelineBegin': DEFAULT_NAMESPACE,
    'title': DEFAULT_NAMESPACE,
    'to': DEFAULT_NAMESPACE,
    'transform': DEFAULT_NAMESPACE,
    'transformBehavior': DEFAULT_NAMESPACE,
    'type': DEFAULT_NAMESPACE,
    'typeof': DEFAULT_NAMESPACE,
    'u1': DEFAULT_NAMESPACE,
    'u2': DEFAULT_NAMESPACE,
    'underline-position': DEFAULT_NAMESPACE,
    'underline-thickness': DEFAULT_NAMESPACE,
    'unicode': DEFAULT_NAMESPACE,
    'unicode-bidi': DEFAULT_NAMESPACE,
    'unicode-range': DEFAULT_NAMESPACE,
    'units-per-em': DEFAULT_NAMESPACE,
    'v-alphabetic': DEFAULT_NAMESPACE,
    'v-hanging': DEFAULT_NAMESPACE,
    'v-ideographic': DEFAULT_NAMESPACE,
    'v-mathematical': DEFAULT_NAMESPACE,
    'values': DEFAULT_NAMESPACE,
    'version': DEFAULT_NAMESPACE,
    'vert-adv-y': DEFAULT_NAMESPACE,
    'vert-origin-x': DEFAULT_NAMESPACE,
    'vert-origin-y': DEFAULT_NAMESPACE,
    'viewBox': DEFAULT_NAMESPACE,
    'viewTarget': DEFAULT_NAMESPACE,
    'visibility': DEFAULT_NAMESPACE,
    'width': DEFAULT_NAMESPACE,
    'widths': DEFAULT_NAMESPACE,
    'word-spacing': DEFAULT_NAMESPACE,
    'writing-mode': DEFAULT_NAMESPACE,
    'x': DEFAULT_NAMESPACE,
    'x-height': DEFAULT_NAMESPACE,
    'x1': DEFAULT_NAMESPACE,
    'x2': DEFAULT_NAMESPACE,
    'xChannelSelector': DEFAULT_NAMESPACE,
    'xlink:actuate': XLINK_NAMESPACE,
    'xlink:arcrole': XLINK_NAMESPACE,
    'xlink:href': XLINK_NAMESPACE,
    'xlink:role': XLINK_NAMESPACE,
    'xlink:show': XLINK_NAMESPACE,
    'xlink:title': XLINK_NAMESPACE,
    'xlink:type': XLINK_NAMESPACE,
    'xml:base': XML_NAMESPACE,
    'xml:id': XML_NAMESPACE,
    'xml:lang': XML_NAMESPACE,
    'xml:space': XML_NAMESPACE,
    'y': DEFAULT_NAMESPACE,
    'y1': DEFAULT_NAMESPACE,
    'y2': DEFAULT_NAMESPACE,
    'yChannelSelector': DEFAULT_NAMESPACE,
    'z': DEFAULT_NAMESPACE,
    'zoomAndPan': DEFAULT_NAMESPACE
};

module.exports = SVGAttributeNamespace;

function SVGAttributeNamespace(value) {
  if (SVG_PROPERTIES.hasOwnProperty(value)) {
    return SVG_PROPERTIES[value];
  }
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/svg.js":[function(require,module,exports){
'use strict';

var isArray = require('x-is-array');

var h = require('./index.js');


var SVGAttributeNamespace = require('./svg-attribute-namespace');
var attributeHook = require('./hooks/attribute-hook');

var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

module.exports = svg;

function svg(tagName, properties, children) {
    if (!children && isChildren(properties)) {
        children = properties;
        properties = {};
    }

    properties = properties || {};

    // set namespace for svg
    properties.namespace = SVG_NAMESPACE;

    var attributes = properties.attributes || (properties.attributes = {});

    for (var key in properties) {
        if (!properties.hasOwnProperty(key)) {
            continue;
        }

        var namespace = SVGAttributeNamespace(key);

        if (namespace === undefined) { // not a svg attribute
            continue;
        }

        var value = properties[key];

        if (typeof value !== 'string' &&
            typeof value !== 'number' &&
            typeof value !== 'boolean'
        ) {
            continue;
        }

        if (namespace !== null) { // namespaced attribute
            properties[key] = attributeHook(namespace, value);
            continue;
        }

        attributes[key] = value
        properties[key] = undefined
    }

    return h(tagName, properties, children);
}

function isChildren(x) {
    return typeof x === 'string' || isArray(x);
}

},{"./hooks/attribute-hook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/hooks/attribute-hook.js","./index.js":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/index.js","./svg-attribute-namespace":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/svg-attribute-namespace.js","x-is-array":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/handle-thunk.js":[function(require,module,exports){
var isVNode = require("./is-vnode")
var isVText = require("./is-vtext")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")

module.exports = handleThunk

function handleThunk(a, b) {
    var renderedA = a
    var renderedB = b

    if (isThunk(b)) {
        renderedB = renderThunk(b, a)
    }

    if (isThunk(a)) {
        renderedA = renderThunk(a, null)
    }

    return {
        a: renderedA,
        b: renderedB
    }
}

function renderThunk(thunk, previous) {
    var renderedThunk = thunk.vnode

    if (!renderedThunk) {
        renderedThunk = thunk.vnode = thunk.render(previous)
    }

    if (!(isVNode(renderedThunk) ||
            isVText(renderedThunk) ||
            isWidget(renderedThunk))) {
        throw new Error("thunk did not return a valid node");
    }

    return renderedThunk
}

},{"./is-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-thunk.js","./is-vnode":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js","./is-vtext":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vtext.js","./is-widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-thunk.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-thunk.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vhook.js":[function(require,module,exports){
module.exports = isHook

function isHook(hook) {
    return hook &&
      (typeof hook.hook === "function" && !hook.hasOwnProperty("hook") ||
       typeof hook.unhook === "function" && !hook.hasOwnProperty("unhook"))
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vnode.js"][0].apply(exports,arguments)
},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vtext.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/node_modules/virtual-dom/vnode/is-vtext.js"][0].apply(exports,arguments)
},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js":[function(require,module,exports){
module.exports = isWidget

function isWidget(w) {
    return w && w.type === "Widget"
}

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js":[function(require,module,exports){
module.exports = "1"

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vnode.js":[function(require,module,exports){
var version = require("./version")
var isVNode = require("./is-vnode")
var isWidget = require("./is-widget")
var isThunk = require("./is-thunk")
var isVHook = require("./is-vhook")

module.exports = VirtualNode

var noProperties = {}
var noChildren = []

function VirtualNode(tagName, properties, children, key, namespace) {
    this.tagName = tagName
    this.properties = properties || noProperties
    this.children = children || noChildren
    this.key = key != null ? String(key) : undefined
    this.namespace = (typeof namespace === "string") ? namespace : null

    var count = (children && children.length) || 0
    var descendants = 0
    var hasWidgets = false
    var hasThunks = false
    var descendantHooks = false
    var hooks

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            var property = properties[propName]
            if (isVHook(property) && property.unhook) {
                if (!hooks) {
                    hooks = {}
                }

                hooks[propName] = property
            }
        }
    }

    for (var i = 0; i < count; i++) {
        var child = children[i]
        if (isVNode(child)) {
            descendants += child.count || 0

            if (!hasWidgets && child.hasWidgets) {
                hasWidgets = true
            }

            if (!hasThunks && child.hasThunks) {
                hasThunks = true
            }

            if (!descendantHooks && (child.hooks || child.descendantHooks)) {
                descendantHooks = true
            }
        } else if (!hasWidgets && isWidget(child)) {
            if (typeof child.destroy === "function") {
                hasWidgets = true
            }
        } else if (!hasThunks && isThunk(child)) {
            hasThunks = true;
        }
    }

    this.count = count + descendants
    this.hasWidgets = hasWidgets
    this.hasThunks = hasThunks
    this.hooks = hooks
    this.descendantHooks = descendantHooks
}

VirtualNode.prototype.version = version
VirtualNode.prototype.type = "VirtualNode"

},{"./is-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-thunk.js","./is-vhook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vhook.js","./is-vnode":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js","./is-widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js","./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vpatch.js":[function(require,module,exports){
var version = require("./version")

VirtualPatch.NONE = 0
VirtualPatch.VTEXT = 1
VirtualPatch.VNODE = 2
VirtualPatch.WIDGET = 3
VirtualPatch.PROPS = 4
VirtualPatch.ORDER = 5
VirtualPatch.INSERT = 6
VirtualPatch.REMOVE = 7
VirtualPatch.THUNK = 8

module.exports = VirtualPatch

function VirtualPatch(type, vNode, patch) {
    this.type = Number(type)
    this.vNode = vNode
    this.patch = patch
}

VirtualPatch.prototype.version = version
VirtualPatch.prototype.type = "VirtualPatch"

},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vtext.js":[function(require,module,exports){
var version = require("./version")

module.exports = VirtualText

function VirtualText(text) {
    this.text = String(text)
}

VirtualText.prototype.version = version
VirtualText.prototype.type = "VirtualText"

},{"./version":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/version.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vtree/diff-props.js":[function(require,module,exports){
var isObject = require("is-object")
var isHook = require("../vnode/is-vhook")

module.exports = diffProps

function diffProps(a, b) {
    var diff

    for (var aKey in a) {
        if (!(aKey in b)) {
            diff = diff || {}
            diff[aKey] = undefined
        }

        var aValue = a[aKey]
        var bValue = b[aKey]

        if (aValue === bValue) {
            continue
        } else if (isObject(aValue) && isObject(bValue)) {
            if (getPrototype(bValue) !== getPrototype(aValue)) {
                diff = diff || {}
                diff[aKey] = bValue
            } else if (isHook(bValue)) {
                 diff = diff || {}
                 diff[aKey] = bValue
            } else {
                var objectDiff = diffProps(aValue, bValue)
                if (objectDiff) {
                    diff = diff || {}
                    diff[aKey] = objectDiff
                }
            }
        } else {
            diff = diff || {}
            diff[aKey] = bValue
        }
    }

    for (var bKey in b) {
        if (!(bKey in a)) {
            diff = diff || {}
            diff[bKey] = b[bKey]
        }
    }

    return diff
}

function getPrototype(value) {
  if (Object.getPrototypeOf) {
    return Object.getPrototypeOf(value)
  } else if (value.__proto__) {
    return value.__proto__
  } else if (value.constructor) {
    return value.constructor.prototype
  }
}

},{"../vnode/is-vhook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vhook.js","is-object":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/is-object/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vtree/diff.js":[function(require,module,exports){
var isArray = require("x-is-array")

var VPatch = require("../vnode/vpatch")
var isVNode = require("../vnode/is-vnode")
var isVText = require("../vnode/is-vtext")
var isWidget = require("../vnode/is-widget")
var isThunk = require("../vnode/is-thunk")
var handleThunk = require("../vnode/handle-thunk")

var diffProps = require("./diff-props")

module.exports = diff

function diff(a, b) {
    var patch = { a: a }
    walk(a, b, patch, 0)
    return patch
}

function walk(a, b, patch, index) {
    if (a === b) {
        return
    }

    var apply = patch[index]
    var applyClear = false

    if (isThunk(a) || isThunk(b)) {
        thunks(a, b, patch, index)
    } else if (b == null) {

        // If a is a widget we will add a remove patch for it
        // Otherwise any child widgets/hooks must be destroyed.
        // This prevents adding two remove patches for a widget.
        if (!isWidget(a)) {
            clearState(a, patch, index)
            apply = patch[index]
        }

        apply = appendPatch(apply, new VPatch(VPatch.REMOVE, a, b))
    } else if (isVNode(b)) {
        if (isVNode(a)) {
            if (a.tagName === b.tagName &&
                a.namespace === b.namespace &&
                a.key === b.key) {
                var propsPatch = diffProps(a.properties, b.properties)
                if (propsPatch) {
                    apply = appendPatch(apply,
                        new VPatch(VPatch.PROPS, a, propsPatch))
                }
                apply = diffChildren(a, b, patch, apply, index)
            } else {
                apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
                applyClear = true
            }
        } else {
            apply = appendPatch(apply, new VPatch(VPatch.VNODE, a, b))
            applyClear = true
        }
    } else if (isVText(b)) {
        if (!isVText(a)) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
            applyClear = true
        } else if (a.text !== b.text) {
            apply = appendPatch(apply, new VPatch(VPatch.VTEXT, a, b))
        }
    } else if (isWidget(b)) {
        if (!isWidget(a)) {
            applyClear = true;
        }

        apply = appendPatch(apply, new VPatch(VPatch.WIDGET, a, b))
    }

    if (apply) {
        patch[index] = apply
    }

    if (applyClear) {
        clearState(a, patch, index)
    }
}

function diffChildren(a, b, patch, apply, index) {
    var aChildren = a.children
    var bChildren = reorder(aChildren, b.children)

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen

    for (var i = 0; i < len; i++) {
        var leftNode = aChildren[i]
        var rightNode = bChildren[i]
        index += 1

        if (!leftNode) {
            if (rightNode) {
                // Excess nodes in b need to be added
                apply = appendPatch(apply,
                    new VPatch(VPatch.INSERT, null, rightNode))
            }
        } else {
            walk(leftNode, rightNode, patch, index)
        }

        if (isVNode(leftNode) && leftNode.count) {
            index += leftNode.count
        }
    }

    if (bChildren.moves) {
        // Reorder nodes last
        apply = appendPatch(apply, new VPatch(VPatch.ORDER, a, bChildren.moves))
    }

    return apply
}

function clearState(vNode, patch, index) {
    // TODO: Make this a single walk, not two
    unhook(vNode, patch, index)
    destroyWidgets(vNode, patch, index)
}

// Patch records for all destroyed widgets must be added because we need
// a DOM node reference for the destroy function
function destroyWidgets(vNode, patch, index) {
    if (isWidget(vNode)) {
        if (typeof vNode.destroy === "function") {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(VPatch.REMOVE, vNode, null)
            )
        }
    } else if (isVNode(vNode) && (vNode.hasWidgets || vNode.hasThunks)) {
        var children = vNode.children
        var len = children.length
        for (var i = 0; i < len; i++) {
            var child = children[i]
            index += 1

            destroyWidgets(child, patch, index)

            if (isVNode(child) && child.count) {
                index += child.count
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

// Create a sub-patch for thunks
function thunks(a, b, patch, index) {
    var nodes = handleThunk(a, b);
    var thunkPatch = diff(nodes.a, nodes.b)
    if (hasPatches(thunkPatch)) {
        patch[index] = new VPatch(VPatch.THUNK, null, thunkPatch)
    }
}

function hasPatches(patch) {
    for (var index in patch) {
        if (index !== "a") {
            return true;
        }
    }

    return false;
}

// Execute hooks when two nodes are identical
function unhook(vNode, patch, index) {
    if (isVNode(vNode)) {
        if (vNode.hooks) {
            patch[index] = appendPatch(
                patch[index],
                new VPatch(
                    VPatch.PROPS,
                    vNode,
                    undefinedKeys(vNode.hooks)
                )
            )
        }

        if (vNode.descendantHooks || vNode.hasThunks) {
            var children = vNode.children
            var len = children.length
            for (var i = 0; i < len; i++) {
                var child = children[i]
                index += 1

                unhook(child, patch, index)

                if (isVNode(child) && child.count) {
                    index += child.count
                }
            }
        }
    } else if (isThunk(vNode)) {
        thunks(vNode, null, patch, index)
    }
}

function undefinedKeys(obj) {
    var result = {}

    for (var key in obj) {
        result[key] = undefined
    }

    return result
}

// List diff, naive left to right reordering
function reorder(aChildren, bChildren) {

    var bKeys = keyIndex(bChildren)

    if (!bKeys) {
        return bChildren
    }

    var aKeys = keyIndex(aChildren)

    if (!aKeys) {
        return bChildren
    }

    var bMatch = {}, aMatch = {}

    for (var aKey in bKeys) {
        bMatch[bKeys[aKey]] = aKeys[aKey]
    }

    for (var bKey in aKeys) {
        aMatch[aKeys[bKey]] = bKeys[bKey]
    }

    var aLen = aChildren.length
    var bLen = bChildren.length
    var len = aLen > bLen ? aLen : bLen
    var shuffle = []
    var freeIndex = 0
    var i = 0
    var moveIndex = 0
    var moves = {}
    var removes = moves.removes = {}
    var reverse = moves.reverse = {}
    var hasMoves = false

    while (freeIndex < len) {
        var move = aMatch[i]
        if (move !== undefined) {
            shuffle[i] = bChildren[move]
            if (move !== moveIndex) {
                moves[move] = moveIndex
                reverse[moveIndex] = move
                hasMoves = true
            }
            moveIndex++
        } else if (i in aMatch) {
            shuffle[i] = undefined
            removes[i] = moveIndex++
            hasMoves = true
        } else {
            while (bMatch[freeIndex] !== undefined) {
                freeIndex++
            }

            if (freeIndex < len) {
                var freeChild = bChildren[freeIndex]
                if (freeChild) {
                    shuffle[i] = freeChild
                    if (freeIndex !== moveIndex) {
                        hasMoves = true
                        moves[freeIndex] = moveIndex
                        reverse[moveIndex] = freeIndex
                    }
                    moveIndex++
                }
                freeIndex++
            }
        }
        i++
    }

    if (hasMoves) {
        shuffle.moves = moves
    }

    return shuffle
}

function keyIndex(children) {
    var i, keys

    for (i = 0; i < children.length; i++) {
        var child = children[i]

        if (child.key !== undefined) {
            keys = keys || {}
            keys[child.key] = i
        }
    }

    return keys
}

function appendPatch(apply, patch) {
    if (apply) {
        if (isArray(apply)) {
            apply.push(patch)
        } else {
            apply = [apply, patch]
        }

        return apply
    } else {
        return patch
    }
}

},{"../vnode/handle-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/handle-thunk.js","../vnode/is-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-thunk.js","../vnode/is-vnode":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vnode.js","../vnode/is-vtext":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-vtext.js","../vnode/is-widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/is-widget.js","../vnode/vpatch":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vnode/vpatch.js","./diff-props":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/vtree/diff-props.js","x-is-array":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/node_modules/x-is-array/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var component, mount, stringify, widget;

component = require('./component');

widget = require('./widget');

mount = require('./mount');

stringify = require('./stringify');

component.use(mount);

component.use(stringify);

module.exports = {
  component: component,
  widget: widget,
  dom: require('virtual-dom/h'),
  svg: require('virtual-dom/virtual-hyperscript/svg'),
  partial: require('vdom-thunk'),
  compose: require('./compose'),
  hook: require('./hook')
};

},{"./component":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/component.coffee","./compose":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/compose.coffee","./hook":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/hook.coffee","./mount":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/mount.coffee","./stringify":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/stringify.coffee","./widget":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/widget.coffee","vdom-thunk":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-thunk/index.js","virtual-dom/h":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/h.js","virtual-dom/virtual-hyperscript/svg":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/virtual-hyperscript/svg.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/stringify.coffee":[function(require,module,exports){
var stringify;

stringify = require('vdom-to-html');

module.exports = function(component, spec) {
  return component.stringify = function(state, params) {
    return stringify(spec.render.call(spec, state, params));
  };
};



},{"vdom-to-html":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/vdom-to-html/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odojs/widget.coffee":[function(require,module,exports){
var Widget, create, extend, widget;

create = require('virtual-dom/create-element');

extend = require('extend');

require('setimmediate');

Widget = (function() {
  function Widget(spec1, state1, params1) {
    this.spec = spec1;
    this.state = state1;
    this.params = params1;
  }

  Widget.prototype.type = 'Widget';

  Widget.prototype.init = function() {
    var dom;
    this.el = this.spec.render.call(this, this.state, this.params);
    dom = create(this.el);
    if (dom !== null) {
      this.el = dom;
    }
    setImmediate((function(_this) {
      return function() {
        if (_this.spec.afterMount != null) {
          return _this.spec.afterMount.call(_this, _this.el, _this.state, _this.params);
        }
      };
    })(this));
    return this.el;
  };

  Widget.prototype.update = function(prev, el) {
    var dom, k, result, v;
    for (k in prev) {
      v = prev[k];
      if (this[k] === void 0) {
        this[k] = v;
      }
    }
    result = el;
    if (this.spec.update != null) {
      result = this.spec.update.call(this, el, this.state, this.params, prev);
      if (result !== null) {
        dom = create(result);
        if (dom !== null) {
          result = dom;
        }
      }
    }
    if (this.spec.onUpdate != null) {
      this.spec.onUpdate.call(this, result, this.state, this.params, prev);
    }
    return result;
  };

  Widget.prototype.destroy = function(el) {
    if (this.spec.beforeUnmount != null) {
      return this.spec.beforeUnmount.call(this, el, this.state, this.params);
    }
  };

  return Widget;

})();

widget = function(spec) {
  var Component, i, len, plugin, ref;
  spec = extend({}, spec);
  Component = function(state, params) {
    return new Widget(spec, state, params);
  };
  Component.use = function(plugin) {
    return plugin(Component, spec);
  };
  ref = widget.plugins;
  for (i = 0, len = ref.length; i < len; i++) {
    plugin = ref[i];
    Component.use(plugin);
  }
  return Component;
};

widget.plugins = [];

widget.use = function(plugin) {
  return widget.plugins.push(plugin);
};

widget.Widget = Widget;

module.exports = widget;



},{"extend":"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js","setimmediate":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/setimmediate/setImmediate.js","virtual-dom/create-element":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/node_modules/virtual-dom/create-element.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/filter.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(items, filter) {
  return items.filter(function(item) {
    var key, test, _ref;
    for (key in filter) {
      test = filter[key];
      if (item[key] === void 0) {
        return false;
      }
      if (test instanceof Array) {
        if (_ref = item[key], __indexOf.call(test, _ref) < 0) {
          return false;
        }
      } else {
        if (item[key] !== test) {
          return false;
        }
      }
    }
    return true;
  });
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/query.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var executequery, executesinglequery, fillproperties, fillproperty, jsonfilter;

jsonfilter = require('./filter');

fillproperty = function(data, shape, subqueries) {
  if (shape.__query != null) {
    return subqueries[shape.__query](data, shape, subqueries);
  }
  return fillproperties(data, shape, subqueries);
};

fillproperties = function(data, shape, subqueries) {
  var key, result, subshape;
  if ((data == null) || data === null) {
    return null;
  }
  if (typeof shape !== 'object') {
    return data;
  }
  result = {};
  for (key in shape) {
    subshape = shape[key];
    if (data[key] == null) {
      continue;
    }
    if (!(subshape instanceof Array)) {
      result[key] = fillproperty(data[key], subshape, subqueries);
      continue;
    }
    if (!(data[key] instanceof Array)) {
      throw Error('Expecting array found ' + typeof data);
    }
    subshape = subshape[0];
    result[key] = data[key].map(function(d) {
      return fillproperty(d, subshape, subqueries);
    });
  }
  return result;
};

executesinglequery = function(data, query, subqueries) {
  var results;
  results = jsonfilter(data, query.__params.filter);
  results = results.map(function(result) {
    return fillproperties(result, query.__shape, subqueries);
  });
  if (results.length === 0) {
    return null;
  }
  if (results.length !== 1) {
    throw new Error('One needed, many found');
  }
  return results[0];
};

executequery = function(data, query, subqueries) {
  var results;
  if (!(query.__shape instanceof Array)) {
    return executesinglequery(data, query, subqueries);
  }
  results = jsonfilter(data, query.__params.filter);
  results = results.map(function(result) {
    return fillproperties(result, query.__shape[0], subqueries);
  });
  return results;
};

module.exports = executequery;

},{"./filter":"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/filter.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/store.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var jsonquery;

jsonquery = require('./query');

module.exports = function(json) {
  return function(query, cb) {
    var e, key, result, value;
    try {
      result = {};
      for (key in query) {
        value = query[key];
        result[key] = jsonquery(json, value, {
          filter: jsonquery
        });
      }
      cb(null, result);
    } catch (_error) {
      e = _error;
      cb(e);
    }
    return function() {};
  };
};

},{"./query":"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/query.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql-localstorage/store.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
module.exports = function(query, cb) {
  var key, result, value;
  result = {};
  for (key in query) {
    value = query[key];
    result[key] = JSON.parse(localStorage[value.__params]);
  }
  cb(null, result);
  return function() {
    return clearTimeout(handle);
  };
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"][0].apply(exports,arguments)
},{"../pipe":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js"][0].apply(exports,arguments)
},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js"][0].apply(exports,arguments)
},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js"][0].apply(exports,arguments)
},{"./context":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/context.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/date-reviver.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/date-reviver.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/diffpatcher.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/diffpatcher.js"][0].apply(exports,arguments)
},{"./contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","./contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","./contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js","./filters/arrays":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/arrays.js","./filters/dates":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/dates.js","./filters/nested":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/nested.js","./filters/texts":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/texts.js","./filters/trivial":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/trivial.js","./pipe":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js","./processor":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/processor.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/environment.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/environment.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/arrays.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/arrays.js"][0].apply(exports,arguments)
},{"../contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","../contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","../contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js","./lcs":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/lcs.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/dates.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/dates.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/lcs.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/lcs.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/nested.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/nested.js"][0].apply(exports,arguments)
},{"../contexts/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/diff.js","../contexts/patch":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/patch.js","../contexts/reverse":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/contexts/reverse.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/texts.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/texts.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/filters/trivial.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/filters/trivial.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/main.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/main.js"][0].apply(exports,arguments)
},{"./date-reviver":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/date-reviver.js","./diffpatcher":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/diffpatcher.js","./environment":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/environment.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/pipe.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/processor.js":[function(require,module,exports){
arguments[4]["/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/node_modules/odoql/node_modules/jsondiffpatch/src/processor.js"][0].apply(exports,arguments)
},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/plugin.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
module.exports = function(component, spec) {
  if (spec.query == null) {
    return component.query = function() {
      return {};
    };
  }
  return component.query = function(params) {
    return spec.query.call(component, params);
  };
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
module.exports = {
  query: function(name, params, shape) {
    return {
      __query: name,
      __params: params,
      __shape: shape
    };
  },
  freshquery: function(name, params, shape) {
    return {
      __query: name,
      __params: params,
      __shape: shape,
      __fresh: true
    };
  },
  desc: require('./ql/desc'),
  merge: require('./ql/merge'),
  split: require('./ql/split'),
  diff: require('./ql/diff'),
  build: require('./ql/build'),
  exec: require('./ql/exec')
};

},{"./ql/build":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/build.js","./ql/desc":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/desc.js","./ql/diff":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/diff.js","./ql/exec":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/exec.js","./ql/merge":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/merge.js","./ql/split":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/split.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/build.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var split;

split = require('./split');

module.exports = function(query, stores) {
  var graph, item, key, queries, result, _, _fn, _ref;
  queries = {};
  query = split(query, Object.keys(stores));
  _ref = query.known;
  for (key in _ref) {
    graph = _ref[key];
    if (queries[graph.__query] == null) {
      queries[graph.__query] = {
        __query: graph.__query,
        keys: [],
        queries: {}
      };
    }
    queries[graph.__query].keys.push(key);
    queries[graph.__query].queries[key] = graph;
  }
  result = [];
  _fn = function(item) {
    item.query = function(cb) {
      return stores[item.__query](item.queries, cb);
    };
    return result.push(item);
  };
  for (_ in queries) {
    item = queries[_];
    _fn(item);
  }
  if (Object.keys(query.unknown).length === 0) {
    return result;
  }
  if (stores.__dynamic == null) {
    return cb(new Error('Unknown queries'));
  }
  result.push({
    __query: '__dynamic',
    keys: Object.keys(query.unknown),
    query: function(cb) {
      return stores.__dynamic(query.unknown, cb);
    },
    queries: query.unknown
  });
  return result;
};

},{"./split":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/split.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/desc.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
module.exports = function(query) {
  if (Object.keys(query).length === 0) {
    return '-- no query --';
  }
  return 'query\n' + Object.keys(query).map(function(prop) {
    return "  " + prop + " from " + query[prop].__query;
  }).join('\n');
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/diff.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var diffisdelete, jsondiffpatch;

jsondiffpatch = require('jsondiffpatch');

diffisdelete = function(diff) {
  return diff instanceof Array && diff.length === 3 && diff[1] === 0 && diff[2] === 0;
};

module.exports = function(prev, next) {
  var diff, key, result, value;
  result = {};
  diff = jsondiffpatch.diff(prev, next);
  for (key in diff) {
    value = diff[key];
    if (diffisdelete(value)) {
      continue;
    }
    result[key] = next[key];
  }
  for (key in next) {
    value = next[key];
    if ((value != null ? value.__fresh : void 0) != null) {
      result[key] = value;
    }
  }
  return result;
};

},{"jsondiffpatch":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/node_modules/jsondiffpatch/src/main.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/exec.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var async, build, extend;

build = require('./build');

async = require('odo-async');

extend = require('extend');

module.exports = function(query, stores, callback) {
  var errors, q, state, tasks, _fn, _i, _len;
  query = build(query, stores);
  errors = [];
  tasks = [];
  state = {};
  _fn = function(q) {
    return tasks.push(function(cb) {
      return q.query(function(err, results) {
        if (err != null) {
          errors.push(err);
        } else {
          extend(state, results);
        }
        return cb();
      });
    });
  };
  for (_i = 0, _len = query.length; _i < _len; _i++) {
    q = query[_i];
    _fn(q);
  }
  return async.parallel(tasks, function() {
    if (errors.length !== 0) {
      return callback(errors, state);
    }
    return callback(null, state);
  });
};

},{"./build":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/build.js","extend":"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js","odo-async":"/Users/tcoats/Mayhem/wedding/node_modules/odo-async/async.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/merge.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var eq, extend, merge;

extend = require('extend');

eq = function(a, b) {
  var aarray, akeys, barray, bkeys, i, key, value, _i, _ref;
  if (a === b) {
    return true;
  }
  if (typeof a !== 'object' || typeof b !== 'object') {
    return false;
  }
  if (a === null || b === null) {
    return false;
  }
  aarray = a instanceof Array;
  barray = b instanceof Array;
  if (aarray !== barray) {
    return false;
  }
  if (aarray) {
    if (a.length !== b.length) {
      return false;
    }
    for (i = _i = 0, _ref = a.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      if (!eq(a[i], b[i])) {
        return false;
      }
    }
    return true;
  }
  akeys = Object.keys(a);
  bkeys = Object.keys(b);
  if (akeys.length !== bkeys.length) {
    return false;
  }
  for (key in a) {
    value = a[key];
    if (!eq(value, b[key])) {
      return false;
    }
  }
  return true;
};

merge = function(base, extra) {
  var aarray, barray, key, value, _results;
  aarray = base instanceof Array;
  barray = extra instanceof Array;
  if (aarray) {
    if (!barray) {
      console.log('Not an array, ignoring');
      console.log(extra);
      return base;
    }
    if (base.length !== 1 || extra.length !== 1) {
      console.log('Expecting length 1 arrays');
      console.log(extra);
      return base;
    }
    return [merge(base[0], extra[0])];
  }
  if (base.__query != null) {
    if (extra.__query == null) {
      console.log('Non query, ignoring');
      console.log(extra);
      return base;
    }
    if (!eq(base.__params, extra.__params)) {
      console.log('Query does not match, ignoring');
      console.log(extra);
      return base;
    }
    if ((base.__shape == null) || (extra.__shape == null)) {
      return base;
    }
    merge(base.__shape, extra.__shape);
    return;
  } else if (extra.__query != null) {
    console.log('Query, ignoring');
    console.log(extra);
    return base;
  }
  _results = [];
  for (key in extra) {
    value = extra[key];
    if ((base[key] != null) && typeof value === 'object') {
      merge(base[key], value);
      continue;
    }
    _results.push(base[key] = value);
  }
  return _results;
};

module.exports = function(queries) {
  var query, result, _i, _len;
  if (arguments.length === 0) {
    return null;
  }
  if (arguments.length !== 1) {
    queries = Array.prototype.slice.call(arguments, 0);
  }
  if (queries.length === 0) {
    return null;
  }
  result = {};
  for (_i = 0, _len = queries.length; _i < _len; _i++) {
    query = queries[_i];
    merge(result, extend({}, query));
  }
  return result;
};

},{"extend":"/Users/tcoats/Mayhem/wedding/node_modules/extend/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/odoql/ql/split.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

module.exports = function(query, names) {
  var key, known, unknown, value, _ref;
  known = {};
  unknown = {};
  for (key in query) {
    value = query[key];
    if (_ref = value.__query, __indexOf.call(names, _ref) >= 0) {
      known[key] = value;
    } else {
      unknown[key] = value;
    }
  }
  return {
    known: known,
    unknown: unknown
  };
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/page/index.js":[function(require,module,exports){
  /* globals require, module */

  'use strict';

  /**
   * Module dependencies.
   */

  var pathtoRegexp = require('path-to-regexp');

  /**
   * Module exports.
   */

  module.exports = page;

  /**
   * To work properly with the URL
   * history.location generated polyfill in https://github.com/devote/HTML5-History-API
   */

  var location = ('undefined' !== typeof window) && (window.history.location || window.location);

  /**
   * Perform initial dispatch.
   */

  var dispatch = true;

  /**
   * Decode URL components (query string, pathname, hash).
   * Accommodates both regular percent encoding and x-www-form-urlencoded format.
   */
  var decodeURLComponents = true;

  /**
   * Base path.
   */

  var base = '';

  /**
   * Running flag.
   */

  var running;

  /**
   * HashBang option
   */

  var hashbang = false;

  /**
   * Previous context, for capturing
   * page exit events.
   */

  var prevContext;

  /**
   * Register `path` with callback `fn()`,
   * or route `path`, or redirection,
   * or `page.start()`.
   *
   *   page(fn);
   *   page('*', fn);
   *   page('/user/:id', load, user);
   *   page('/user/' + user.id, { some: 'thing' });
   *   page('/user/' + user.id);
   *   page('/from', '/to')
   *   page();
   *
   * @param {String|Function} path
   * @param {Function} fn...
   * @api public
   */

  function page(path, fn) {
    // <callback>
    if ('function' === typeof path) {
      return page('*', path);
    }

    // route <path> to <callback ...>
    if ('function' === typeof fn) {
      var route = new Route(path);
      for (var i = 1; i < arguments.length; ++i) {
        page.callbacks.push(route.middleware(arguments[i]));
      }
      // show <path> with [state]
    } else if ('string' === typeof path) {
      page['string' === typeof fn ? 'redirect' : 'show'](path, fn);
      // start [options]
    } else {
      page.start(path);
    }
  }

  /**
   * Callback functions.
   */

  page.callbacks = [];
  page.exits = [];

  /**
   * Current path being processed
   * @type {String}
   */
  page.current = '';

  /**
   * Number of pages navigated to.
   * @type {number}
   *
   *     page.len == 0;
   *     page('/login');
   *     page.len == 1;
   */

  page.len = 0;

  /**
   * Get or set basepath to `path`.
   *
   * @param {String} path
   * @api public
   */

  page.base = function(path) {
    if (0 === arguments.length) return base;
    base = path;
  };

  /**
   * Bind with the given `options`.
   *
   * Options:
   *
   *    - `click` bind to click events [true]
   *    - `popstate` bind to popstate [true]
   *    - `dispatch` perform initial dispatch [true]
   *
   * @param {Object} options
   * @api public
   */

  page.start = function(options) {
    options = options || {};
    if (running) return;
    running = true;
    if (false === options.dispatch) dispatch = false;
    if (false === options.decodeURLComponents) decodeURLComponents = false;
    if (false !== options.popstate) window.addEventListener('popstate', onpopstate, false);
    if (false !== options.click) window.addEventListener('click', onclick, false);
    if (true === options.hashbang) hashbang = true;
    if (!dispatch) return;
    var url = (hashbang && ~location.hash.indexOf('#!')) ? location.hash.substr(2) + location.search : location.pathname + location.search + location.hash;
    page.replace(url, null, true, dispatch);
  };

  /**
   * Unbind click and popstate event handlers.
   *
   * @api public
   */

  page.stop = function() {
    if (!running) return;
    page.current = '';
    page.len = 0;
    running = false;
    window.removeEventListener('click', onclick, false);
    window.removeEventListener('popstate', onpopstate, false);
  };

  /**
   * Show `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @param {Boolean} dispatch
   * @return {Context}
   * @api public
   */

  page.show = function(path, state, dispatch, push) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    if (false !== dispatch) page.dispatch(ctx);
    if (false !== ctx.handled && false !== push) ctx.pushState();
    return ctx;
  };

  /**
   * Goes back in the history
   * Back should always let the current route push state and then go back.
   *
   * @param {String} path - fallback path to go back if no more history exists, if undefined defaults to page.base
   * @param {Object} [state]
   * @api public
   */

  page.back = function(path, state) {
    if (page.len > 0) {
      // this may need more testing to see if all browsers
      // wait for the next tick to go back in history
      history.back();
      page.len--;
    } else if (path) {
      setTimeout(function() {
        page.show(path, state);
      });
    }else{
      setTimeout(function() {
        page.show(base, state);
      });
    }
  };


  /**
   * Register route to redirect from one path to other
   * or just redirect to another route
   *
   * @param {String} from - if param 'to' is undefined redirects to 'from'
   * @param {String} [to]
   * @api public
   */
  page.redirect = function(from, to) {
    // Define route from a path to another
    if ('string' === typeof from && 'string' === typeof to) {
      page(from, function(e) {
        setTimeout(function() {
          page.replace(to);
        }, 0);
      });
    }

    // Wait for the push state and replace it with another
    if ('string' === typeof from && 'undefined' === typeof to) {
      setTimeout(function() {
        page.replace(from);
      }, 0);
    }
  };

  /**
   * Replace `path` with optional `state` object.
   *
   * @param {String} path
   * @param {Object} state
   * @return {Context}
   * @api public
   */


  page.replace = function(path, state, init, dispatch) {
    var ctx = new Context(path, state);
    page.current = ctx.path;
    ctx.init = init;
    ctx.save(); // save before dispatching, which may redirect
    if (false !== dispatch) page.dispatch(ctx);
    return ctx;
  };

  /**
   * Dispatch the given `ctx`.
   *
   * @param {Object} ctx
   * @api private
   */

  page.dispatch = function(ctx) {
    var prev = prevContext,
      i = 0,
      j = 0;

    prevContext = ctx;

    function nextExit() {
      var fn = page.exits[j++];
      if (!fn) return nextEnter();
      fn(prev, nextExit);
    }

    function nextEnter() {
      var fn = page.callbacks[i++];

      if (ctx.path !== page.current) {
        ctx.handled = false;
        return;
      }
      if (!fn) return unhandled(ctx);
      fn(ctx, nextEnter);
    }

    if (prev) {
      nextExit();
    } else {
      nextEnter();
    }
  };

  /**
   * Unhandled `ctx`. When it's not the initial
   * popstate then redirect. If you wish to handle
   * 404s on your own use `page('*', callback)`.
   *
   * @param {Context} ctx
   * @api private
   */

  function unhandled(ctx) {
    if (ctx.handled) return;
    var current;

    if (hashbang) {
      current = base + location.hash.replace('#!', '');
    } else {
      current = location.pathname + location.search;
    }

    if (current === ctx.canonicalPath) return;
    page.stop();
    ctx.handled = false;
    location.href = ctx.canonicalPath;
  }

  /**
   * Register an exit route on `path` with
   * callback `fn()`, which will be called
   * on the previous context when a new
   * page is visited.
   */
  page.exit = function(path, fn) {
    if (typeof path === 'function') {
      return page.exit('*', path);
    }

    var route = new Route(path);
    for (var i = 1; i < arguments.length; ++i) {
      page.exits.push(route.middleware(arguments[i]));
    }
  };

  /**
   * Remove URL encoding from the given `str`.
   * Accommodates whitespace in both x-www-form-urlencoded
   * and regular percent-encoded form.
   *
   * @param {str} URL component to decode
   */
  function decodeURLEncodedURIComponent(val) {
    if (typeof val !== 'string') { return val; }
    return decodeURLComponents ? decodeURIComponent(val.replace(/\+/g, ' ')) : val;
  }

  /**
   * Initialize a new "request" `Context`
   * with the given `path` and optional initial `state`.
   *
   * @param {String} path
   * @param {Object} state
   * @api public
   */

  function Context(path, state) {
    if ('/' === path[0] && 0 !== path.indexOf(base)) path = base + (hashbang ? '#!' : '') + path;
    var i = path.indexOf('?');

    this.canonicalPath = path;
    this.path = path.replace(base, '') || '/';
    if (hashbang) this.path = this.path.replace('#!', '') || '/';

    this.title = document.title;
    this.state = state || {};
    this.state.path = path;
    this.querystring = ~i ? decodeURLEncodedURIComponent(path.slice(i + 1)) : '';
    this.pathname = decodeURLEncodedURIComponent(~i ? path.slice(0, i) : path);
    this.params = {};

    // fragment
    this.hash = '';
    if (!hashbang) {
      if (!~this.path.indexOf('#')) return;
      var parts = this.path.split('#');
      this.path = parts[0];
      this.hash = decodeURLEncodedURIComponent(parts[1]) || '';
      this.querystring = this.querystring.split('#')[0];
    }
  }

  /**
   * Expose `Context`.
   */

  page.Context = Context;

  /**
   * Push state.
   *
   * @api private
   */

  Context.prototype.pushState = function() {
    page.len++;
    history.pushState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Save the context state.
   *
   * @api public
   */

  Context.prototype.save = function() {
    history.replaceState(this.state, this.title, hashbang && this.path !== '/' ? '#!' + this.path : this.canonicalPath);
  };

  /**
   * Initialize `Route` with the given HTTP `path`,
   * and an array of `callbacks` and `options`.
   *
   * Options:
   *
   *   - `sensitive`    enable case-sensitive routes
   *   - `strict`       enable strict matching for trailing slashes
   *
   * @param {String} path
   * @param {Object} options.
   * @api private
   */

  function Route(path, options) {
    options = options || {};
    this.path = (path === '*') ? '(.*)' : path;
    this.method = 'GET';
    this.regexp = pathtoRegexp(this.path,
      this.keys = [],
      options.sensitive,
      options.strict);
  }

  /**
   * Expose `Route`.
   */

  page.Route = Route;

  /**
   * Return route middleware with
   * the given callback `fn()`.
   *
   * @param {Function} fn
   * @return {Function}
   * @api public
   */

  Route.prototype.middleware = function(fn) {
    var self = this;
    return function(ctx, next) {
      if (self.match(ctx.path, ctx.params)) return fn(ctx, next);
      next();
    };
  };

  /**
   * Check if this route matches `path`, if so
   * populate `params`.
   *
   * @param {String} path
   * @param {Object} params
   * @return {Boolean}
   * @api private
   */

  Route.prototype.match = function(path, params) {
    var keys = this.keys,
      qsIndex = path.indexOf('?'),
      pathname = ~qsIndex ? path.slice(0, qsIndex) : path,
      m = this.regexp.exec(decodeURIComponent(pathname));

    if (!m) return false;

    for (var i = 1, len = m.length; i < len; ++i) {
      var key = keys[i - 1];
      var val = decodeURLEncodedURIComponent(m[i]);
      if (val !== undefined || !(hasOwnProperty.call(params, key.name))) {
        params[key.name] = val;
      }
    }

    return true;
  };

  /**
   * Handle "populate" events.
   */

  function onpopstate(e) {
    if (e.state) {
      var path = e.state.path;
      page.replace(path, e.state);
    } else {
      page.show(location.pathname + location.hash, undefined, undefined, false);
    }
  }

  /**
   * Handle "click" events.
   */

  function onclick(e) {

    if (1 !== which(e)) return;

    if (e.metaKey || e.ctrlKey || e.shiftKey) return;
    if (e.defaultPrevented) return;



    // ensure link
    var el = e.target;
    while (el && 'A' !== el.nodeName) el = el.parentNode;
    if (!el || 'A' !== el.nodeName) return;



    // Ignore if tag has
    // 1. "download" attribute
    // 2. rel="external" attribute
    if (el.getAttribute('download') || el.getAttribute('rel') === 'external') return;

    // ensure non-hash for the same path
    var link = el.getAttribute('href');
    if (!hashbang && el.pathname === location.pathname && (el.hash || '#' === link)) return;



    // Check for mailto: in the href
    if (link && link.indexOf('mailto:') > -1) return;

    // check target
    if (el.target) return;

    // x-origin
    if (!sameOrigin(el.href)) return;



    // rebuild path
    var path = el.pathname + el.search + (el.hash || '');

    // same page
    var orig = path;

    path = path.replace(base, '');
    if (hashbang) path = path.replace('#!', '');



    if (base && orig === path) return;

    e.preventDefault();
    page.show(orig);
  }

  /**
   * Event button.
   */

  function which(e) {
    e = e || window.event;
    return null === e.which ? e.button : e.which;
  }

  /**
   * Check if `href` is the same origin.
   */

  function sameOrigin(href) {
    var origin = location.protocol + '//' + location.hostname;
    if (location.port) origin += ':' + location.port;
    return (href && (0 === href.indexOf(origin)));
  }

  page.sameOrigin = sameOrigin;

},{"path-to-regexp":"/Users/tcoats/Mayhem/wedding/node_modules/page/node_modules/path-to-regexp/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/page/node_modules/path-to-regexp/index.js":[function(require,module,exports){
var isArray = require('isarray');

/**
 * Expose `pathToRegexp`.
 */
module.exports = pathToRegexp;

/**
 * The main path matching regexp utility.
 *
 * @type {RegExp}
 */
var PATH_REGEXP = new RegExp([
  // Match escaped characters that would otherwise appear in future matches.
  // This allows the user to escape special characters that won't transform.
  '(\\\\.)',
  // Match Express-style parameters and un-named parameters with a prefix
  // and optional suffixes. Matches appear as:
  //
  // "/:test(\\d+)?" => ["/", "test", "\d+", undefined, "?"]
  // "/route(\\d+)" => [undefined, undefined, undefined, "\d+", undefined]
  '([\\/.])?(?:\\:(\\w+)(?:\\(((?:\\\\.|[^)])*)\\))?|\\(((?:\\\\.|[^)])*)\\))([+*?])?',
  // Match regexp special characters that are always escaped.
  '([.+*?=^!:${}()[\\]|\\/])'
].join('|'), 'g');

/**
 * Escape the capturing group by escaping special characters and meaning.
 *
 * @param  {String} group
 * @return {String}
 */
function escapeGroup (group) {
  return group.replace(/([=!:$\/()])/g, '\\$1');
}

/**
 * Attach the keys as a property of the regexp.
 *
 * @param  {RegExp} re
 * @param  {Array}  keys
 * @return {RegExp}
 */
function attachKeys (re, keys) {
  re.keys = keys;
  return re;
}

/**
 * Get the flags for a regexp from the options.
 *
 * @param  {Object} options
 * @return {String}
 */
function flags (options) {
  return options.sensitive ? '' : 'i';
}

/**
 * Pull out keys from a regexp.
 *
 * @param  {RegExp} path
 * @param  {Array}  keys
 * @return {RegExp}
 */
function regexpToRegexp (path, keys) {
  // Use a negative lookahead to match only capturing groups.
  var groups = path.source.match(/\((?!\?)/g);

  if (groups) {
    for (var i = 0; i < groups.length; i++) {
      keys.push({
        name:      i,
        delimiter: null,
        optional:  false,
        repeat:    false
      });
    }
  }

  return attachKeys(path, keys);
}

/**
 * Transform an array into a regexp.
 *
 * @param  {Array}  path
 * @param  {Array}  keys
 * @param  {Object} options
 * @return {RegExp}
 */
function arrayToRegexp (path, keys, options) {
  var parts = [];

  for (var i = 0; i < path.length; i++) {
    parts.push(pathToRegexp(path[i], keys, options).source);
  }

  var regexp = new RegExp('(?:' + parts.join('|') + ')', flags(options));
  return attachKeys(regexp, keys);
}

/**
 * Replace the specific tags with regexp strings.
 *
 * @param  {String} path
 * @param  {Array}  keys
 * @return {String}
 */
function replacePath (path, keys) {
  var index = 0;

  function replace (_, escaped, prefix, key, capture, group, suffix, escape) {
    if (escaped) {
      return escaped;
    }

    if (escape) {
      return '\\' + escape;
    }

    var repeat   = suffix === '+' || suffix === '*';
    var optional = suffix === '?' || suffix === '*';

    keys.push({
      name:      key || index++,
      delimiter: prefix || '/',
      optional:  optional,
      repeat:    repeat
    });

    prefix = prefix ? ('\\' + prefix) : '';
    capture = escapeGroup(capture || group || '[^' + (prefix || '\\/') + ']+?');

    if (repeat) {
      capture = capture + '(?:' + prefix + capture + ')*';
    }

    if (optional) {
      return '(?:' + prefix + '(' + capture + '))?';
    }

    // Basic parameter support.
    return prefix + '(' + capture + ')';
  }

  return path.replace(PATH_REGEXP, replace);
}

/**
 * Normalize the given path string, returning a regular expression.
 *
 * An empty array can be passed in for the keys, which will hold the
 * placeholder key descriptions. For example, using `/user/:id`, `keys` will
 * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
 *
 * @param  {(String|RegExp|Array)} path
 * @param  {Array}                 [keys]
 * @param  {Object}                [options]
 * @return {RegExp}
 */
function pathToRegexp (path, keys, options) {
  keys = keys || [];

  if (!isArray(keys)) {
    options = keys;
    keys = [];
  } else if (!options) {
    options = {};
  }

  if (path instanceof RegExp) {
    return regexpToRegexp(path, keys, options);
  }

  if (isArray(path)) {
    return arrayToRegexp(path, keys, options);
  }

  var strict = options.strict;
  var end = options.end !== false;
  var route = replacePath(path, keys);
  var endsWithSlash = path.charAt(path.length - 1) === '/';

  // In non-strict mode we allow a slash at the end of match. If the path to
  // match already ends with a slash, we remove it for consistency. The slash
  // is valid at the end of a path match, not in the middle. This is important
  // in non-ending mode, where "/test/" shouldn't match "/test//route".
  if (!strict) {
    route = (endsWithSlash ? route.slice(0, -2) : route) + '(?:\\/(?=$))?';
  }

  if (end) {
    route += '$';
  } else {
    // In non-ending mode, we need the capturing groups to match as much as
    // possible by using a positive lookahead to the end or next path segment.
    route += strict && endsWithSlash ? '' : '(?=\\/|$)';
  }

  return attachKeys(new RegExp('^' + route, flags(options)), keys);
}

},{"isarray":"/Users/tcoats/Mayhem/wedding/node_modules/page/node_modules/path-to-regexp/node_modules/isarray/index.js"}],"/Users/tcoats/Mayhem/wedding/node_modules/page/node_modules/path-to-regexp/node_modules/isarray/index.js":[function(require,module,exports){
module.exports = Array.isArray || function (arr) {
  return Object.prototype.toString.call(arr) == '[object Array]';
};

},{}],"/Users/tcoats/Mayhem/wedding/node_modules/svg4everybody/svg4everybody.js":[function(require,module,exports){
(function (document, uses, requestAnimationFrame, CACHE, IE9TO11) {
	function embed(svg, g) {
		if (g) {
			var
			viewBox = g.getAttribute('viewBox'),
			fragment = document.createDocumentFragment(),
			clone = g.cloneNode(true);

			if (viewBox) {
				svg.setAttribute('viewBox', viewBox);
			}

			while (clone.childNodes.length) {
				fragment.appendChild(clone.childNodes[0]);
			}

			svg.appendChild(fragment);
		}
	}

	function onload() {
		var xhr = this, x = document.createElement('x'), s = xhr.s;

		x.innerHTML = xhr.responseText;

		xhr.onload = function () {
			s.splice(0).map(function (array) {
				embed(array[0], x.querySelector('#' + array[1].replace(/(\W)/g, '\\$1')));
			});
		};

		xhr.onload();
	}

	function onframe() {
		var use;

		while ((use = uses[0])) {
			var
			svg = use.parentNode,
			url = use.getAttribute('xlink:href').split('#'),
			url_root = url[0],
			url_hash = url[1];

			svg.removeChild(use);

			if (url_root.length) {
				var xhr = CACHE[url_root] = CACHE[url_root] || new XMLHttpRequest();

				if (!xhr.s) {
					xhr.s = [];

					xhr.open('GET', url_root);

					xhr.onload = onload;

					xhr.send();
				}

				xhr.s.push([svg, url_hash]);

				if (xhr.readyState === 4) {
					xhr.onload();
				}

			} else {
				embed(svg, document.getElementById(url_hash));
			}
		}

		requestAnimationFrame(onframe);
	}

	if (IE9TO11) {
		onframe();
	}
})(
	document,
	document.getElementsByTagName('use'),
	window.requestAnimationFrame || window.setTimeout,
	{},
	/Trident\/[567]\b/.test(navigator.userAgent) || (navigator.userAgent.match(/AppleWebKit\/(\d+)/) || [])[1] < 537
);

},{}],"/Users/tcoats/Mayhem/wedding/plumbing/form2js.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1

/**
 * Copyright (c) 2010 Maxim Vasiliev
#
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
#
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
#
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
#
 * @author Maxim Vasiliev
 * Date: 09.09.2010
 * Time: 19:02:33
 */
(function(root, factory) {
  if (typeof exports !== 'undefined' && typeof module !== 'undefined' && module.exports) {
    module.exports = factory();
  } else if (typeof define === 'function' && define.amd) {
    define(factory);
  } else {
    root.form2js = factory();
  }
})(this, function() {

  /**
   * Returns form values represented as Javascript object
   * "name" attribute defines structure of resulting object
  #
   * @param rootNode {Element|String} root form element (or it's id) or array of root elements
   * @param delimiter {String} structure parts delimiter defaults to '.'
   * @param skipEmpty {Boolean} should skip empty text values, defaults to true
   * @param nodeCallback {Function} custom function to get node value
   * @param useIdIfEmptyName {Boolean} if true value of id attribute of field will be used if name of field is empty
   */
  var extractNodeValues, form2js, getFieldName, getFieldValue, getFormValues, getSelectedOptionValue, getSubFormValues, processNameValues;
  form2js = function(rootNode, delimiter, skipEmpty, nodeCallback, useIdIfEmptyName, getDisabled) {
    var currNode, formValues, i;
    getDisabled = getDisabled ? true : false;
    if (typeof skipEmpty === 'undefined' || skipEmpty === null) {
      skipEmpty = true;
    }
    if (typeof delimiter === 'undefined' || delimiter === null) {
      delimiter = '.';
    }
    if (arguments.length < 5) {
      useIdIfEmptyName = false;
    }
    rootNode = typeof rootNode === 'string' ? document.getElementById(rootNode) : rootNode;
    formValues = [];
    currNode = void 0;
    i = 0;

    /* If rootNode is array - combine values */
    if (rootNode.constructor === Array || typeof NodeList !== 'undefined' && rootNode.constructor === NodeList) {
      while (currNode = rootNode[i++]) {
        formValues = formValues.concat(getFormValues(currNode, nodeCallback, useIdIfEmptyName, getDisabled));
      }
    } else {
      formValues = getFormValues(rootNode, nodeCallback, useIdIfEmptyName, getDisabled);
    }
    return processNameValues(formValues, skipEmpty, delimiter);
  };

  /**
   * Processes collection of { name: 'name', value: 'value' } objects.
   * @param nameValues
   * @param skipEmpty if true skips elements with value == '' or value == null
   * @param delimiter
   */
  processNameValues = function(nameValues, skipEmpty, delimiter) {
    var _nameParts, arrIdx, arrName, arrNameFull, arrays, currResult, i, j, k, l, name, namePart, nameParts, result, value;
    result = {};
    arrays = {};
    i = void 0;
    j = void 0;
    k = void 0;
    l = void 0;
    value = void 0;
    nameParts = void 0;
    currResult = void 0;
    arrNameFull = void 0;
    arrName = void 0;
    arrIdx = void 0;
    namePart = void 0;
    name = void 0;
    _nameParts = void 0;
    i = 0;
    while (i < nameValues.length) {
      value = nameValues[i].value;
      if (skipEmpty && (value === '' || value === null)) {
        i++;
        continue;
      }
      name = nameValues[i].name;
      _nameParts = name.split(delimiter);
      nameParts = [];
      currResult = result;
      arrNameFull = '';
      j = 0;
      while (j < _nameParts.length) {
        namePart = _nameParts[j].split('][');
        if (namePart.length > 1) {
          k = 0;
          while (k < namePart.length) {
            if (k === 0) {
              namePart[k] = namePart[k] + ']';
            } else if (k === namePart.length - 1) {
              namePart[k] = '[' + namePart[k];
            } else {
              namePart[k] = '[' + namePart[k] + ']';
            }
            arrIdx = namePart[k].match(/([a-z_]+)?\[([a-z_][a-z0-9_]+?)\]/i);
            if (arrIdx) {
              l = 1;
              while (l < arrIdx.length) {
                if (arrIdx[l]) {
                  nameParts.push(arrIdx[l]);
                }
                l++;
              }
            } else {
              nameParts.push(namePart[k]);
            }
            k++;
          }
        } else {
          nameParts = nameParts.concat(namePart);
        }
        j++;
      }
      j = 0;
      while (j < nameParts.length) {
        namePart = nameParts[j];
        if (namePart.indexOf('[]') > -1 && j === nameParts.length - 1) {
          arrName = namePart.substr(0, namePart.indexOf('['));
          arrNameFull += arrName;
          if (!currResult[arrName]) {
            currResult[arrName] = [];
          }
          currResult[arrName].push(value);
        } else if (namePart.indexOf('[') > -1) {
          arrName = namePart.substr(0, namePart.indexOf('['));
          arrIdx = namePart.replace(/(^([a-z_]+)?\[)|(\]$)/gi, '');

          /* Unique array name */
          arrNameFull += '_' + arrName + '_' + arrIdx;

          /*
           * Because arrIdx in field name can be not zero-based and step can be
           * other than 1, we can't use them in target array directly.
           * Instead we're making a hash where key is arrIdx and value is a reference to
           * added array element
           */
          if (!arrays[arrNameFull]) {
            arrays[arrNameFull] = {};
          }
          if (arrName !== '' && !currResult[arrName]) {
            currResult[arrName] = [];
          }
          if (j === nameParts.length - 1) {
            if (arrName === '') {
              currResult.push(value);
              arrays[arrNameFull][arrIdx] = currResult[currResult.length - 1];
            } else {
              currResult[arrName].push(value);
              arrays[arrNameFull][arrIdx] = currResult[arrName][currResult[arrName].length - 1];
            }
          } else {
            if (!arrays[arrNameFull][arrIdx]) {
              if (/^[0-9a-z_]+\[?/i.test(nameParts[j + 1])) {
                currResult[arrName].push({});
              } else {
                currResult[arrName].push([]);
              }
              arrays[arrNameFull][arrIdx] = currResult[arrName][currResult[arrName].length - 1];
            }
          }
          currResult = arrays[arrNameFull][arrIdx];
        } else {
          arrNameFull += namePart;
          if (j < nameParts.length - 1) {
            if (!currResult[namePart]) {
              currResult[namePart] = {};
            }
            currResult = currResult[namePart];
          } else {
            currResult[namePart] = value;
          }
        }
        j++;
      }
      i++;
    }
    return result;
  };
  getFormValues = function(rootNode, nodeCallback, useIdIfEmptyName, getDisabled) {
    var result;
    result = extractNodeValues(rootNode, nodeCallback, useIdIfEmptyName, getDisabled);
    if (result.length > 0) {
      return result;
    } else {
      return getSubFormValues(rootNode, nodeCallback, useIdIfEmptyName, getDisabled);
    }
  };
  getSubFormValues = function(rootNode, nodeCallback, useIdIfEmptyName, getDisabled) {
    var currentNode, result;
    result = [];
    currentNode = rootNode.firstChild;
    while (currentNode) {
      result = result.concat(extractNodeValues(currentNode, nodeCallback, useIdIfEmptyName, getDisabled));
      currentNode = currentNode.nextSibling;
    }
    return result;
  };
  extractNodeValues = function(node, nodeCallback, useIdIfEmptyName, getDisabled) {
    var callbackResult, fieldName, fieldValue, result;
    if (node.disabled && !getDisabled) {
      return [];
    }
    callbackResult = void 0;
    fieldValue = void 0;
    result = void 0;
    fieldName = getFieldName(node, useIdIfEmptyName);
    callbackResult = nodeCallback && nodeCallback(node);
    if (callbackResult && callbackResult.name) {
      result = [callbackResult];
    } else if (fieldName !== '' && node.nodeName.match(/INPUT|TEXTAREA/i)) {
      fieldValue = getFieldValue(node, getDisabled);
      if (null === fieldValue) {
        result = [];
      } else {
        result = [
          {
            name: fieldName,
            value: fieldValue
          }
        ];
      }
    } else if (fieldName !== '' && node.nodeName.match(/SELECT/i)) {
      fieldValue = getFieldValue(node, getDisabled);
      result = [
        {
          name: fieldName.replace(/\[\]$/, ''),
          value: fieldValue
        }
      ];
    } else {
      result = getSubFormValues(node, nodeCallback, useIdIfEmptyName, getDisabled);
    }
    return result;
  };
  getFieldName = function(node, useIdIfEmptyName) {
    if (node.name && node.name !== '') {
      return node.name;
    } else if (useIdIfEmptyName && node.id && node.id !== '') {
      return node.id;
    } else {
      return '';
    }
  };
  getFieldValue = function(fieldNode, getDisabled) {
    if (fieldNode.disabled && !getDisabled) {
      return null;
    }
    switch (fieldNode.nodeName) {
      case 'INPUT':
      case 'TEXTAREA':
        switch (fieldNode.type.toLowerCase()) {
          case 'radio':
            if (fieldNode.checked && fieldNode.value === 'false') {
              return false;
            }
            break;
          case 'checkbox':
            if (fieldNode.checked && fieldNode.value === 'true') {
              return true;
            }
            if (!fieldNode.checked && fieldNode.value === 'true') {
              return false;
            }
            if (fieldNode.checked) {
              return fieldNode.value;
            }
            break;
          case 'button':
          case 'reset':
          case 'submit':
          case 'image':
            return '';
          default:
            return fieldNode.value;
            break;
        }
        break;
      case 'SELECT':
        return getSelectedOptionValue(fieldNode);
      default:
        break;
    }
    return null;
  };
  getSelectedOptionValue = function(selectNode) {
    var i, l, multiple, options, result;
    multiple = selectNode.multiple;
    result = [];
    options = void 0;
    i = void 0;
    l = void 0;
    if (!multiple) {
      return selectNode.value;
    }
    options = selectNode.getElementsByTagName('option');
    i = 0;
    l = options.length;
    while (i < l) {
      if (options[i].selected) {
        result.push(options[i].value);
      }
      i++;
    }
    return result;
  };
  'use strict';
  return form2js;
});

},{}],"/Users/tcoats/Mayhem/wedding/plumbing/intent.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1

/*
  Register things to do when various events fire
 */
var hub, scene;

hub = require('odo-hub');

scene = require('./scene');

hub.all(function(e, description, p, cb) {
  var timings;
  if (e === 'queries starting') {
    console.log("? " + p.description);
  } else if (e === 'queries completed') {
    timings = Object.keys(p).map(function(prop) {
      return "  " + prop + " in " + p[prop] + "ms";
    }).join('\n');
    console.log("√ completed\n" + timings);
  } else {
    console.log("+ " + description);
  }
  return cb();
});

hub.every('{eventid} RSVP {attending}', function(p, cb) {
  var delta, transaction;
  delta = {
    invite: {}
  };
  delta.invite[p.eventid] = {
    going: p.attending
  };
  transaction = scene.layer(delta);
  scene.update();
  return cb();
});

hub.every('{eventid} attendee {index} is {name}', function(p, cb) {
  var attending, delta, transaction;
  attending = scene.state().invite[p.eventid].attending.slice(0);
  attending[p.index] = name;
  delta = {
    invite: {}
  };
  delta.invite[p.eventid] = {
    attending: attending
  };
  transaction = scene.layer(delta);
  scene.update();
  return cb();
});

hub.every('navigate to the default page', function(p, cb) {
  scene.update({
    page: {
      name: 'default',
      code: p.code
    }
  });
  return cb();
});

hub.every('navigation error, {pathname} not found', function(p, cb) {
  scene.update({
    page: {
      name: 'error',
      message: p.pathname + " not found"
    }
  });
  return cb();
});

},{"./scene":"/Users/tcoats/Mayhem/wedding/plumbing/scene.js","odo-hub":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/hub.js"}],"/Users/tcoats/Mayhem/wedding/plumbing/router.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var Router, component, dom, getpage, hub, inject, page, ref;

ref = require('odojs'), component = ref.component, dom = ref.dom;

inject = require('injectinto');

hub = require('odo-hub');

page = require('page');

page('/:invite', function(e) {
  return hub.emit('navigate to the default page', e.params);
});

page(function(details) {
  return hub.emit('navigation error, {pathname} not found', details);
});

getpage = function(params) {
  var ref1;
  page = (ref1 = params.page) != null ? ref1 : 'default';
  if (page instanceof Object) {
    page = page.name;
  }
  return inject.one("page:" + page);
};

Router = component({
  query: function(params) {
    return getpage(params).query(params);
  },
  render: function(state, params) {
    return getpage(params)(state, params);
  }
});

inject.bind('router', Router);

module.exports = Router;

},{"injectinto":"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js","odo-hub":"/Users/tcoats/Mayhem/wedding/node_modules/odo-hub/hub.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js","page":"/Users/tcoats/Mayhem/wedding/node_modules/page/index.js"}],"/Users/tcoats/Mayhem/wedding/plumbing/scene.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var Router, body, component, odoql, ref, relay, scene, stores, widget;

ref = require('odojs'), component = ref.component, widget = ref.widget;

odoql = require('odoql/plugin');

relay = require('odo-relay');

component.use(odoql);

widget.use(odoql);

require('../components/');

require('../ui/');

Router = require('./router');

Router.use(relay);

body = document.querySelector('body');

stores = require('./stores');

scene = relay(body, Router, stores);

module.exports = scene;

},{"../components/":"/Users/tcoats/Mayhem/wedding/components/index.js","../ui/":"/Users/tcoats/Mayhem/wedding/ui/index.js","./router":"/Users/tcoats/Mayhem/wedding/plumbing/router.js","./stores":"/Users/tcoats/Mayhem/wedding/plumbing/stores.js","odo-relay":"/Users/tcoats/Mayhem/wedding/node_modules/odo-relay/relay.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js","odoql/plugin":"/Users/tcoats/Mayhem/wedding/node_modules/odoql/plugin.js"}],"/Users/tcoats/Mayhem/wedding/plumbing/stores.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var get, jsonstore, localstore, stores;

jsonstore = require('odoql-json/store');

localstore = require('odoql-localstorage/store');

get = function(url, cb) {
  var http;
  http = new XMLHttpRequest();
  http.onreadystatechange = function() {
    if (http.readyState !== XMLHttpRequest.DONE) {
      return;
    }
    if (http.status === 200) {
      return cb(null, JSON.parse(http.responseText));
    }
    return cb({
      status: http.status,
      message: http.responseText
    });
  };
  http.open('GET', url, true);
  return http.send();
};

stores = {
  localstorage: localstore,
  __dynamic: function(query, cb) {
    query = encodeURIComponent(JSON.stringify(query));
    return get("/query?q=" + query, cb);
  }
};

module.exports = stores;

},{"odoql-json/store":"/Users/tcoats/Mayhem/wedding/node_modules/odoql-json/store.js","odoql-localstorage/store":"/Users/tcoats/Mayhem/wedding/node_modules/odoql-localstorage/store.js"}],"/Users/tcoats/Mayhem/wedding/ui/icons.js":[function(require,module,exports){
// Generated by CoffeeScript 1.9.1
var Icon, component, dom, inject, ref, svg;

ref = require('odojs'), component = ref.component, dom = ref.dom, svg = ref.svg;

inject = require('injectinto');

require('svg4everybody');

Icon = component({
  render: function(state, params) {
    return dom('span', [
      svg('svg', {
        attributes: {
          role: 'img',
          "class": 'icon'
        }
      }, [
        svg('use', {
          'xlink:href': "/dist/wedding-1.0.0.min.svg#" + params.i
        })
      ])
    ]);
  }
});

inject.bind('icon', Icon);

module.exports = Icon;

},{"injectinto":"/Users/tcoats/Mayhem/wedding/node_modules/injectinto/inject.js","odojs":"/Users/tcoats/Mayhem/wedding/node_modules/odojs/odo.js","svg4everybody":"/Users/tcoats/Mayhem/wedding/node_modules/svg4everybody/svg4everybody.js"}],"/Users/tcoats/Mayhem/wedding/ui/index.js":[function(require,module,exports){
// Generated by CoffeeScript 1.8.0
require('./icons');

},{"./icons":"/Users/tcoats/Mayhem/wedding/ui/icons.js"}]},{},["./plumbing/index.coffee"])


//# sourceMappingURL=wedding-1.0.0.min.js.map